<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nuxt3.5正式发布</title>
    <url>/2023/05/18/Nuxt3-5%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h1 id="「摘要」"><a href="#「摘要」" class="headerlink" title="「摘要」"></a>「摘要」</h1><p>5 月 16 日，Nuxt 3.5.0 正式发布，它带来了 Vue 3.3 版本、新的默认设置、交互式服务端组件、类型化页面、环境配置等。<br>Nuxt 是使用简便的 Web 框架，用于构建现代和高性能的 Web 应用，可以部署在任何运行 JavaScript 的平台上。去年发布的 Nuxt 3 基于 Vue 3 构建，为 TypeScript 提供了 “一等公民” 支持，并进行了一次彻底的重构，对内核进行了精简，速度更快，体验更好。</p>
<h1 id="「一、Vue-3-3」"><a href="#「一、Vue-3-3」" class="headerlink" title="「一、Vue 3.3」"></a>「一、Vue 3.3」</h1><p>Vue 3.3 已经发布，具有许多令人兴奋的特性，特别是在类型支持方面。包括：</p>
<ul>
<li>宏中的导入和复杂类型支持</li>
<li>通用组件</li>
<li>更符合人体工程学的 defineEmits</li>
<li>使用 defineSlots 的类型插槽</li>
<li>响应式 Props 解构</li>
<li>defineModel</li>
<li>defineOptions</li>
<li>使用 toRef 和 toValue 实现更好的 getter 支持</li>
<li>JSX 导入源支持</li>
<li>维护基础设施改进<h1 id="「二、Nitropack-v2-4」"><a href="#「二、Nitropack-v2-4」" class="headerlink" title="「二、Nitropack v2.4」"></a>「二、Nitropack v2.4」</h1>Nuxt.js 团队一直致力于对 Nitro 进行大量改进，这些改进已经在 Nitro v2.4 中实现——其中包含许多错误修复、Cloudflare 模块工作格式的更新、Vercel KV 支持等。<br>注意：如果需要部署到 Vercel 或 Netlify 并希望从增量静态再生中受益，应该更新路由规则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">routeRules: &#123;</span><br><span class="line">--  &#x27;/blog/**&#x27;: &#123; swr: 3000 &#125;,</span><br><span class="line">++  &#x27;/blog/**&#x27;: &#123; isr: 3000 &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="「三、丰富的-JSON-负载」"><a href="#「三、丰富的-JSON-负载」" class="headerlink" title="「三、丰富的 JSON 负载」"></a>「三、丰富的 JSON 负载」</h1>现在默认启用丰富的 JSON 负载序列化。这既更快又允许序列化从 Nuxt 服务端传递到客户端的有效载荷中的复杂对象（以及在为预渲染站点提取有效载荷数据时）。<br>现在这意味着开箱即用地支持各种丰富的 JS 类型：正则表达式、日期、Map 和 Set 以及 BigInt 以及 NuxtError，以及 Vue 特定的对象，如 ref、reactive、shallowRef 和 shallowReactive。<br>长期以来，由于序列化 Errors 和其他非 POJO 对象的问题，Nuxt 一直在使用自己的 devalue fork，但现在已经过渡回原始版本。我们甚至可以使用新的对象语法Nuxt插件注册自定义类型：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default definePayloadPlugin(() =&gt; &#123;</span><br><span class="line">  definePayloadReducer(&#x27;BlinkingText&#x27;, data =&gt; data === &#x27;&lt;original-blink&gt;&#x27; &amp;&amp; &#x27;_&#x27;)</span><br><span class="line">  definePayloadReviver(&#x27;BlinkingText&#x27;, () =&gt; &#x27;&lt;revivified-blink&gt;&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="「四、交互式服务端组件」"><a href="#「四、交互式服务端组件」" class="headerlink" title="「四、交互式服务端组件」"></a>「四、交互式服务端组件」</h1>这个功能应该被认为是高度实验性的，现在通过插槽支持服务端组件内的交互式内容。</li>
</ul>
<h1 id="「五、环境配置」"><a href="#「五、环境配置」" class="headerlink" title="「五、环境配置」"></a>「五、环境配置」</h1><p>现在可以在 nuxt.config 中配置完全类型化的、按环境的覆盖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default defineNuxtConfig(&#123;</span><br><span class="line">  $production: &#123;</span><br><span class="line">    routeRules: &#123;</span><br><span class="line">      &#x27;/**&#x27;: &#123; isr: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  $development: &#123;</span><br><span class="line">    //</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果正在创作图层，还可以使用 $meta 关键字来提供元数据，层的使用者可能会用到它。</p>
<h1 id="「六、完全类型化的页面」"><a href="#「六、完全类型化的页面」" class="headerlink" title="「六、完全类型化的页面」"></a>「六、完全类型化的页面」</h1><p>通过与unplugin-vue-router的实验性整合，可以在Nuxt应用中受益于完全类型化的路由。<br>开箱即用，这将启用对navigateTo、<NuxtLink>、router.push()等功能的类型化使用。<br>甚至可以通过使用const route = useRoute(‘route-name’)在页面内获取类型化的参数。<br>直接在nuxt.config中启用此功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default defineNuxtConfig(&#123;</span><br><span class="line">  experimental: &#123;</span><br><span class="line">    typedPages: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="「七、Bundler的模块解析」"><a href="#「七、Bundler的模块解析」" class="headerlink" title="「七、Bundler的模块解析」"></a>「七、Bundler的模块解析」</h1><p>现在，Nuxt内部完全支持使用 bundler 策略进行模块解析。<br>如果可能，建议采用此方法。它具有对子路径导出的类型支持，但与 Node16 解析相比，更准确地匹配了诸如 Vite 和 Nuxt 这样的构建工具的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default defineNuxtConfig(&#123;</span><br><span class="line">  typescript: &#123;</span><br><span class="line">    tsConfig: &#123;</span><br><span class="line">      compilerOptions: &#123;</span><br><span class="line">        moduleResolution: &#x27;bundler&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这将开启TypeScript跟踪Node子路径导出的功能。例如，如果一个库有一个像mylib/path这样的子路径导出，映射到mylib/dist/path.mjs，那么可以从mylib/dist/path.d.ts中引入此类型，而不需要库作者创建mylib/path.d.ts。</p>
<h1 id="「八、分离的服务端类型」"><a href="#「八、分离的服务端类型」" class="headerlink" title="「八、分离的服务端类型」"></a>「八、分离的服务端类型」</h1><p>Nuxt 团队计划通过为<del>/server目录生成单独的tsconfig.json来改善IDE中”nitro”和”vue”部分之间的清晰度。<br>可以通过添加一个额外的</del>/server/tsconfig.json并使用以下内容来使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;../.nuxt/tsconfig.server.json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然现在在类型检查 (nuxi typecheck) 时不会考虑这些值，但应该在 IDE 中获得更好的类型提示。</p>
<h1 id="「九、弃用内容」"><a href="#「九、弃用内容」" class="headerlink" title="「九、弃用内容」"></a>「九、弃用内容」</h1><p>虽然没有为 Nuxt 2 中的build.extend钩子提供类型或文档，但一直在webpack 中调用它，现在明确地弃用了它，并将在将来的小版本中删除它。</p>
<h1 id="「十、升级」"><a href="#「十、升级」" class="headerlink" title="「十、升级」"></a>「十、升级」</h1><p>建议运行以下命令进行升级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nuxi upgrade --force</span><br></pre></td></tr></table></figure>
<p>这也将刷新 lockfile 文件，并确保从 Nuxt 依赖的其他依赖项中获取更新，特别是在 unjs 生态系统中。<br>参考：<a href="https://nuxt.com/blog/v3-5">https://nuxt.com/blog/v3-5</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>Nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title>Hooks</title>
    <url>/2022/12/08/Hooks/</url>
    <content><![CDATA[<h1 id="1、为什么要封装-Hooks-？"><a href="#1、为什么要封装-Hooks-？" class="headerlink" title="1、为什么要封装 Hooks ？"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p>
<h2 id="你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？"><a href="#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？" class="headerlink" title="你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p>
<h2 id="哪什么是Hooks封装呢？"><a href="#哪什么是Hooks封装呢？" class="headerlink" title="哪什么是Hooks封装呢？"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p>
<h1 id="2、如何封装-Hooks-呢？"><a href="#2、如何封装-Hooks-呢？" class="headerlink" title="2、如何封装 Hooks 呢？"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p>
<h2 id="把它封装在以use-开头的Hooks函数中，有什么样的好处呢？"><a href="#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？" class="headerlink" title="把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p>
<h1 id="3、在哪些情况下需要封装-Hooks呢？我总结了两种场景："><a href="#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：" class="headerlink" title="3、在哪些情况下需要封装 Hooks呢？我总结了两种场景："></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p>
<h1 id="4、示例：功能类-Hooks封装"><a href="#4、示例：功能类-Hooks封装" class="headerlink" title="4、示例：功能类 Hooks封装"></a>4、示例：功能类 Hooks封装</h1><p><img src="/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="5、示例：业务类-Hooks封装"><a href="#5、示例：业务类-Hooks封装" class="headerlink" title="5、示例：业务类 Hooks封装"></a>5、示例：业务类 Hooks封装</h1><p><img src="/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="封装Hooks不能为了封装而封装。要考虑以下几点："><a href="#封装Hooks不能为了封装而封装。要考虑以下几点：" class="headerlink" title="封装Hooks不能为了封装而封装。要考虑以下几点："></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol>
<li>是否有复用的价值？</li>
<li>是否有利于逻辑的分离？</li>
<li>是否有助提升代码的可阅读性和可维护性？</li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinia 与 Vuex 的区别</title>
    <url>/2023/04/05/Pinia%E4%B8%8EVuex%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><ol>
<li>Vuex的核心概念有state,getters,mutations,actions,moudles五个部分<br>Pinia的核心概念有state,getter,action三个部分</li>
<li>2 mutation 已被弃用。它们经常被认为是极其冗余的</li>
<li>3不再有嵌套结构的moudles，store的命名取决于它的定义方式，实现一种扁平架构</li>
<li>Vuex对state的修改推荐使用mutations中的方法进行修改,<br>Pinia直接对state进行修改</li>
<li>Pinia中 getter，action 也可通过 this 访问整个 store 实例<h1 id="main-js中"><a href="#main-js中" class="headerlink" title="main.js中"></a>main.js中</h1>在main.js中，vuecli会自动将vuex挂载到app上，使用vite需要自己手动挂载pinia<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>  </span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();  </span><br><span class="line">app.<span class="title function_">use</span>(pinia);</span><br></pre></td></tr></table></figure>
<h1 id="store-index-js中"><a href="#store-index-js中" class="headerlink" title="store/index.js中"></a>store/index.js中</h1>vuex有state,getter,mutation,action,moudle五个部分<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; receiveMessagePerson &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/receiveMessagePerson&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">memberOrAdmin</span>: <span class="string">&quot;member&quot;</span>,</span><br><span class="line">    <span class="attr">searchPerson</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setMemberOrAdmin</span>(<span class="params">context, data</span>)&#123;</span><br><span class="line">      context.<span class="property">memberOrAdmin</span> = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">getPerson</span>(<span class="params">context</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> userId = context.<span class="property">state</span>.<span class="property">PersonId</span></span><br><span class="line">      <span class="variable constant_">API</span>.<span class="title function_">getAllInformation</span>(&#123;userId&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;setPerson&#x27;</span>,res.<span class="property">data</span>)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    receiveMessagePerson</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
Pinia有state,getter,action三个部分<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTestStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;Test&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">cuont</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">double</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">cuont</span>*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increase</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cuont</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="在vue组件中"><a href="#在vue组件中" class="headerlink" title="在vue组件中"></a>在vue组件中</h1><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2>vue2中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.***</span><br></pre></td></tr></table></figure>
vue3中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="keyword">let</span> *** = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.***)</span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;**&#x27;</span>, **)</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;**&#x27;</span>, **)</span><br></pre></td></tr></table></figure>
<h2 id="vuex拆解"><a href="#vuex拆解" class="headerlink" title="vuex拆解"></a>vuex拆解</h2>vue2中：<br>使用到mapState,mapGetter,mapMutations,mapActions方法,[_post/Vuex的namespaced属性.md]<br>vue3中：<h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useTestStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/index&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">useTestStore</span>()</span><br><span class="line">store.**(state变量名)</span><br><span class="line">store.**(getters变量名)</span><br><span class="line">store.**(actions方法名)</span><br></pre></td></tr></table></figure>
省去了state,getters,commit,dispatch这些字段，更方便<h2 id="Pinia拆解"><a href="#Pinia拆解" class="headerlink" title="Pinia拆解"></a>Pinia拆解</h2>用到storeToRefs<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line">   <span class="comment">// state和getters的变量都可以拆解出来</span></span><br><span class="line"><span class="keyword">let</span> &#123; **, ** &#125; = <span class="title function_">storeToRefs</span>(store) </span><br><span class="line"><span class="comment">// actions的方法拆解出来</span></span><br><span class="line"><span class="keyword">let</span> &#123; ** &#125; = store                   </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript5.1正式发布</title>
    <url>/2023/06/06/TypeScript5.1%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>2023 年 6 月 1 日，TypeScript5.1 正式发布了。新版本中新增了几个功能，一会儿带大家一起了解一下。<br>你可以通过以下命令进行安装新版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install typescript@beta</span><br></pre></td></tr></table></figure>

<p>新版本中新增了以下主要功能：</p>
<ul>
<li>改进函数返回值类型 undefined 的类型推断</li>
<li>getter 和 setter 支持设置不同类型</li>
<li>JSX 元素和 JSX 标签类型之间解耦类型检查</li>
<li>带命名空间的 JSX 标签</li>
<li>typeRoots 在模块解析中被查询</li>
<li>JSX 标签支持链接光标</li>
<li>@Param JSDoc 标签中支持代码补全</li>
<li>优化<br>接下来我们就一起来了解一下新增的功能。</li>
</ul>
<h1 id="「一、改进函数返回值类型-undefined-的类型推断」"><a href="#「一、改进函数返回值类型-undefined-的类型推断」" class="headerlink" title="「一、改进函数返回值类型 undefined 的类型推断」"></a>「一、改进函数返回值类型 undefined 的类型推断」</h1><p>在 JavaScript 中，如果函数没有返回值，就会返回 undefined，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  // 没有 return</span><br><span class="line">&#125;</span><br><span class="line">// x = undefined</span><br><span class="line">let x = foo()</span><br></pre></td></tr></table></figure>

<p>在以前版本的 TypeScript 中，只有返回值类型为 void 和 any 的函数可以没有 return 语句。这意味着，即使明确知道这个函数是返回 undefined 的，也需要至少有一个 return 语句。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ✅ 推断 f1 返回 void</span><br><span class="line">function f1() &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ void 不需要 return 语句</span><br><span class="line">function f2(): void &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  ✅ any 不需要 return 语句</span><br><span class="line">function f3(): any &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ❌ 声明类型既不是 void 也不是 any 的函数必须返回一个值。</span><br><span class="line">function f4(): undefined &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有时候可能会希望函数返回 undefined 。在之前的版本中，可能需要显式返回一个 undefined 或者显式添加一个 return 语句。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare function takesFunction(f: () =&gt; undefined): undefined</span><br><span class="line"></span><br><span class="line">// ❌ 类型“() =&gt; void”的参数不能赋给类型“() =&gt; undefined”的参数。不能将类型“void”分配给类型“undefined”。</span><br><span class="line">takesFunction(() =&gt; &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ❌ 其声明类型不为 &quot;void&quot; 或 &quot;any&quot; 的函数必须返回值。</span><br><span class="line">takesFunction((): undefined =&gt; &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ❌ 类型“() =&gt; void”的参数不能赋给类型“() =&gt; undefined”的参数。不能将类型“void”分配给类型“undefined”。</span><br><span class="line">takesFunction(() =&gt; &#123;</span><br><span class="line">  return</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ✅ 显式返回 undefined</span><br><span class="line">takesFunction(() =&gt; &#123;</span><br><span class="line">  return undefined</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ✅ 显式添加 return 语句</span><br><span class="line">takesFunction((): undefined =&gt; &#123;</span><br><span class="line">  return</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 TypeScript5.1 版本中，就允许返回 undefined 的函数没有 return 语句。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ✅</span><br><span class="line">function f4(): undefined &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅</span><br><span class="line">takesFunction((): undefined =&gt; &#123;</span><br><span class="line">  // no returns</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果函数没有 return 并且被传递给期望返回 undefined 的函数参数，TypeScript 会推断该函数的返回类型为 undefined。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ✅</span><br><span class="line">takesFunction(function f() &#123;</span><br><span class="line">  // ^ 返回值类型为 undefined</span><br><span class="line"></span><br><span class="line">  // no returns</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ✅</span><br><span class="line">takesFunction(function f() &#123;</span><br><span class="line">  // ^ 返回值类型为 undefined</span><br><span class="line">  return</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了解决另一个类似的痛点，在 TypeScript 的 –noImplicitReturns 选项下，仅返回 undefined 的函数现在具有与 void 类似的异常，因为并非每个代码路径都必须以显式 return 结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ✅ 启用 &#x27;--noImplicitReturns&#x27;</span><br><span class="line">function f(): undefined &#123;</span><br><span class="line">  if (Math.random()) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="「二、getter-和-setter-支持设置不同类型」"><a href="#「二、getter-和-setter-支持设置不同类型」" class="headerlink" title="「二、getter 和 setter 支持设置不同类型」"></a>「二、getter 和 setter 支持设置不同类型」</h1><p>在 TypeScript 4.3 版本中， get 和 set 访问器对可以指定两种不同的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Serializer &#123;</span><br><span class="line">  set value(v: string | number | boolean)</span><br><span class="line">  get value(): string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare let box: Serializer</span><br><span class="line"></span><br><span class="line">// 允许赋值为 &#x27;boolean&#x27;</span><br><span class="line">box.value = true</span><br><span class="line"></span><br><span class="line">// 类型为 &#x27;string&#x27;</span><br><span class="line">console.log(box.value.toUpperCase())</span><br></pre></td></tr></table></figure>

<p>刚开始要求 get 类型必须是 set 类型的子类型。如以下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">box.value = box.value</span><br></pre></td></tr></table></figure>

<p>但是也存在现有的和提议的 API 在它们的 getter 和 setter 之间具有完全不相关的类型。<br>例如，一个最常见的例子——DOM 和 CSSStyleRule API 中的 style 属性。每个样式规则都有一个 style 属性，即 CSSStyleDeclaration；但是，如果尝试写入该属性，它只能使用字符串才有效。<br>在新版本 TypeScript 5.1 版本中，允许 get 和 set 访问器属性设置不同的类型，前提是它们具有显式类型注释。虽然此版本的 TypeScript 尚未更改这些内置接口的类型，但现在可以通过以下方式定义 CSSStyleRule：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface CSSStyleRule &#123;</span><br><span class="line">    get style(): CSSStyleDeclaration</span><br><span class="line">    set style(newValue: string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也允许以下方式使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SafeBox &#123;</span><br><span class="line">    #value: string | undefined</span><br><span class="line">    // 只接受字符串</span><br><span class="line">    set value(newValue: string) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 必须检查 undefined</span><br><span class="line">    get value(): string | undefined &#123;</span><br><span class="line">        return this.#value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就类似于在 –exactOptionalProperties 下检查可选属性的方式。</p>
<h1 id="「三、JSX-元素和-JSX-标签类型之间解耦类型检查」"><a href="#「三、JSX-元素和-JSX-标签类型之间解耦类型检查」" class="headerlink" title="「三、JSX 元素和 JSX 标签类型之间解耦类型检查」"></a>「三、JSX 元素和 JSX 标签类型之间解耦类型检查」</h1><p>TypeScript 对 JSX 的一个痛点是它对每个 JSX 元素标签类型的要求。此版本的 TypeScript 使 JSX 库可以更准确地描述 JSX 组件可以返回的内容，这具体意味着可以在 React 中使用异步服务端组件。<br>例如，有以下 JSX 元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  自闭合的 JSX 标签</span><br><span class="line">&lt;Foo /&gt;</span><br><span class="line"></span><br><span class="line">// 带有开始/结束标签的常规元素</span><br><span class="line">&lt;Bar&gt;&lt;/Bar&gt;</span><br></pre></td></tr></table></figure>

<p>当对 <Foo /> 或 <Bar></Bar> 进行类型检查时，TypeScript 总是会查找名为 JSX 的命名空间，并从中获取一个名为 Element 的类型，也就是在查找 JSX.Element。<br>但是为了检查 Foo 或 Bar 本身是否是有效的标签名称，TypeScript 会粗略地获取由 Foo 或 Bar 返回或构造的类型，并检查与 JSX.Element 的兼容性（或者如果类型是可构造的，则检查另一种称为 JSX.ElementClass 的类型）。<br>这个限制意味着如果组件返回比 JSX.Element 更广泛的类型，则无法使用组件。例如，JSX 库可能可以接受一个返回字符串或 Promise 的组件。举一个具体的例子，React 的未来版本提议对返回 Promise 的组件提供有限支持，但是现有版本的 TypeScript 无法表达这种类型，除非彻底放宽 JSX.Element 的类型限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import * as React from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">async function Foo() &#123;</span><br><span class="line">    return &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let element = &lt;Foo /&gt;</span><br><span class="line">// “Foo”不能用作 JSX 组件。其返回类型 &quot;Promise&lt;Element&gt;&quot; 不是有效的 JSX 元素。</span><br></pre></td></tr></table></figure>

<p>为了向库提供一种表达方式，TypeScript 5.1 现在会查找名为 JSX.ElementType 的类型。ElementType 精确指定什么可以有效用作 JSX 元素中的标签。因此，现在它的类型可能会被定义为类似于以下这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace JSX &#123;</span><br><span class="line">    export type ElementType =</span><br><span class="line">        // 所有有效的小写标签</span><br><span class="line">        keyof IntrinsicAttributes</span><br><span class="line">        // 函数组件</span><br><span class="line">        (props: any) =&gt; Element</span><br><span class="line">        // 类组件</span><br><span class="line">        new (props: any) =&gt; ElementClass;</span><br><span class="line"></span><br><span class="line">    export interface IntrinsictAttributes extends /*...*/ &#123;&#125;</span><br><span class="line">    export type Element = /*...*/;</span><br><span class="line">    export type ClassElement = /*...*/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="「带命名空间的-JSX-标签」"><a href="#「带命名空间的-JSX-标签」" class="headerlink" title="「带命名空间的 JSX 标签」"></a>「带命名空间的 JSX 标签」</h1><p>TypeScript 现在支持在使用 JSX 时使用带命名空间的属性名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import * as React from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">// 这两个是等价的：</span><br><span class="line">const x = &lt;Foo a:b=&quot;hello&quot; /&gt;</span><br><span class="line">const y = &lt;Foo a : b=&quot;hello&quot; /&gt;</span><br><span class="line"></span><br><span class="line">interface FooProps &#123;</span><br><span class="line">    &quot;a:b&quot;: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Foo(props: FooProps) &#123;</span><br><span class="line">    return &lt;div&gt;&#123;props[&quot;a:b&quot;]&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当名称的第一部分是小写字母时，在 JSX.IntrinsicAttributes 上以类似的方式查找命名空间标签名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在某些库的代码中或在该库的扩展中：</span><br><span class="line">namespace JSX &#123;</span><br><span class="line">    interface IntrinsicElements &#123;</span><br><span class="line">        [&quot;a:b&quot;]: &#123; prop: string &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在我们的代码中：</span><br><span class="line">let x = &lt;a:b prop=&quot;hello!&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="「typeRoots-在模块解析中被查询」"><a href="#「typeRoots-在模块解析中被查询」" class="headerlink" title="「typeRoots 在模块解析中被查询」"></a>「typeRoots 在模块解析中被查询」</h1><p>当 TypeScript 指定的模块查找策略无法解析路径时，它现在将解析相对于指定 typeRoots 的包。</p>
<h1 id="「JSX-标签支持链接光标」"><a href="#「JSX-标签支持链接光标」" class="headerlink" title="「JSX 标签支持链接光标」"></a>「JSX 标签支持链接光标」</h1><p>TypeScript 现在支持 JSX 标签名称的链接编辑。也就是在编辑开始/结束标签时，会自动修改结束/开始标签。<br><img src="/2023/06/06/TypeScript5.1%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/image.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>这项新功能应该适用于 TypeScript 和 JavaScript 文件，并且可以在 Visual Studio Code Insiders 中启用。在 Visual Studio Code 中，勾选 Editor: Linked Editing 选项即可：<br><img src="/2023/06/06/TypeScript5.1%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/image-1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>或者在 JSON 设置文件中配置 editor.linkedEditing：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  &quot;editor.linkedEditing&quot;: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Visual Studio 17.7 Preview 1 也将支持此功能。</p>
<h1 id="「-Param-JSDoc-标签中支持代码补全」"><a href="#「-Param-JSDoc-标签中支持代码补全」" class="headerlink" title="「@Param JSDoc 标签中支持代码补全」"></a>「@Param JSDoc 标签中支持代码补全」</h1><p>在 TypeScript 和 JavaScript 文件中输入 @param 标签时，TypeScript 现在提供代码补全。<br><img src="/2023/06/06/TypeScript5.1%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/image-2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="「优化」"><a href="#「优化」" class="headerlink" title="「优化」"></a>「优化」</h1><h1 id="「避免不必要的类型实例化」"><a href="#「避免不必要的类型实例化」" class="headerlink" title="「避免不必要的类型实例化」"></a>「避免不必要的类型实例化」</h1><p>TypeScript 5.1 现在避免在已知不包含对外部类型参数的引用的对象类型中执行类型实例化。这有可能减少许多不必要的计算，并将 material-ui 的文档目录的类型检查时间减少 50% 以上。</p>
<h1 id="「联合字面量类型检查优化」"><a href="#「联合字面量类型检查优化」" class="headerlink" title="「联合字面量类型检查优化」"></a>「联合字面量类型检查优化」</h1><p>在检查源类型是否属于联合类型时，TypeScript 首先将使用该源类型的内部类型标识符进行快速查找。如果查找失败，则 TypeScript 会针对联合类型中的每种类型检查其兼容性。当将字面类型与仅包含字面类型的联合类型相关联时，TypeScript 现在可以避免针对联合类型中的每种其他类型进行完整遍历。</p>
<p>这种优化可以将此问题中的代码的类型检查时间从约 45 秒减少到约 0.4 秒。</p>
<h1 id="「进行-JSDoc-解析时减少对扫描器的调用」"><a href="#「进行-JSDoc-解析时减少对扫描器的调用」" class="headerlink" title="「进行 JSDoc 解析时减少对扫描器的调用」"></a>「进行 JSDoc 解析时减少对扫描器的调用」</h1><p>当旧版本的 TypeScript 分析 JSDoc 注释时，它们会使用扫描器/分词器将注释分解为细粒度的标记并将内容拼凑在一起。这可能有助于规范化注释文本，这样多个空格就会合并为一个。但这也意味着解析器和扫描器会经常来回跳转，从而增加 JSDoc 解析的开销。</p>
<p>TypeScript 5.1 在将 JSDoc 注释分解为扫描器/分词器方面更改了逻辑。扫描器现在将更大的内容块直接返回给解析器，以便根据需要进行处理。</p>
<p>这些更改已将几个 10Mb 的主要是注释的 JavaScript 文件的解析时间缩短了大约一半。</p>
<h1 id="「总结」"><a href="#「总结」" class="headerlink" title="「总结」"></a>「总结」</h1><p>以上新增的功能，还在了解学习中……</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-axios</title>
    <url>/2022/12/19/Vue-axios/</url>
    <content><![CDATA[<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p>
<h1 id="一、前端从后端获取数据的方式通常采用http-https的方式"><a href="#一、前端从后端获取数据的方式通常采用http-https的方式" class="headerlink" title="一、前端从后端获取数据的方式通常采用http/https的方式"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p>
<h1 id="二、从前端请求后端接口获取数据格式："><a href="#二、从前端请求后端接口获取数据格式：" class="headerlink" title="二、从前端请求后端接口获取数据格式："></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p>
<h2 id="1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑"><a href="#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑" class="headerlink" title="1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id="2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑"><a href="#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑" class="headerlink" title="2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p>
<h2 id="POST方法（appcation-json或者form-data）："><a href="#POST方法（appcation-json或者form-data）：" class="headerlink" title="POST方法（appcation/json或者form-data）："></a>POST方法（appcation/json或者form-data）：</h2><h3 id="1、①appcation-json方式"><a href="#1、①appcation-json方式" class="headerlink" title="1、①appcation/json方式"></a>1、①appcation/json方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data=&#123;id:12&#125;</span><br><span class="line">axios.post(url,data,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="②appcation-json方式："><a href="#②appcation-json方式：" class="headerlink" title="②appcation/json方式："></a>②appcation/json方式：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data=&#123;id:12&#125;</span><br><span class="line">axios(&#123;method:&#x27;post&#x27;,url,data:data,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2、①form-data方式"><a href="#2、①form-data方式" class="headerlink" title="2、①form-data方式"></a>2、①form-data方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data=&#123;id:12&#125;</span><br><span class="line">let formData = new FormData()</span><br><span class="line">for(let key in data)&#123;</span><br><span class="line">formData.append(key,data[key])</span><br><span class="line">&#125;</span><br><span class="line">axios.post(url,formData,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="②form-data方式"><a href="#②form-data方式" class="headerlink" title="②form-data方式"></a>②form-data方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data=&#123;id:12&#125;</span><br><span class="line">let formData = new FormData()</span><br><span class="line">for(let key in data)&#123;</span><br><span class="line">formData.append(key,data[key])</span><br><span class="line">&#125;</span><br><span class="line">axios(&#123;method:&#x27;post&#x27;,url,formData:formData,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>
<p>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p>
<h2 id="PUT和PATCH方式："><a href="#PUT和PATCH方式：" class="headerlink" title="PUT和PATCH方式："></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p>
<h2 id="DELETE方式："><a href="#DELETE方式：" class="headerlink" title="DELETE方式："></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p>
<h1 id="三、axios并发请求"><a href="#三、axios并发请求" class="headerlink" title="三、axios并发请求"></a>三、axios并发请求</h1><h2 id="并发请求：同时进行多个请求，并统一处理返回值。"><a href="#并发请求：同时进行多个请求，并统一处理返回值。" class="headerlink" title="并发请求：同时进行多个请求，并统一处理返回值。"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p>
<h2 id="axios-all-和axios-spread-方法"><a href="#axios-all-和axios-spread-方法" class="headerlink" title="axios.all()和axios.spread()方法"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p>
<h2 id="另一个axios-spread-A-B-gt"><a href="#另一个axios-spread-A-B-gt" class="headerlink" title="另一个axios.spread((A,B)=&gt;{})"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;&#123;&#125;))</span><br></pre></td></tr></table></figure>
<h1 id="四、axios实例"><a href="#四、axios实例" class="headerlink" title="四、axios实例"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let instance = axios.create(config);</span><br><span class="line">instance.get(url).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="五、关于请求中的config"><a href="#五、关于请求中的config" class="headerlink" title="五、关于请求中的config"></a>五、关于请求中的config</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config的格式为：</span><br><span class="line">&#123;</span><br><span class="line">baseURL:&#x27;http:/xxxxxx&#x27;, //基础url</span><br><span class="line">timeout:6000, //超时时间</span><br><span class="line">url:xxxxxx, //具体url</span><br><span class="line">method:&#x27;get/post/put/patch/delete&#x27;, //请求方式</span><br><span class="line">headers:&#123;token:&#x27;xxxxx&#x27;等&#125;, //请求头设置</span><br><span class="line">params:&#123;&#125;, //请求参数对象，它会将请求参数拼接到url上</span><br><span class="line">data:&#123;&#125; //请求参数对象，它会将请求参数放到请求体中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>config应用场景</p>
<h2 id="1、全局配置"><a href="#1、全局配置" class="headerlink" title="1、全局配置"></a>1、全局配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.timeout = 1000</span><br><span class="line">axios.defaults.baseURL = &#x27;http://XXXXX&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="2、实例配置"><a href="#2、实例配置" class="headerlink" title="2、实例配置"></a>2、实例配置</h2><p>在axios创建实例中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let instance = axios.create();</span><br><span class="line">instance.defaults.timeout = 1000</span><br></pre></td></tr></table></figure>
<h2 id="3、请求配置"><a href="#3、请求配置" class="headerlink" title="3、请求配置"></a>3、请求配置</h2><p>在请求中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>
<p>其中，配置优先级为：3&gt;2&gt;1</p>
<h1 id="六、axios拦截器"><a href="#六、axios拦截器" class="headerlink" title="六、axios拦截器"></a>六、axios拦截器</h1><h2 id="什么是拦截器？"><a href="#什么是拦截器？" class="headerlink" title="什么是拦截器？"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p>
<h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service.interceptors.request.use(</span><br><span class="line">config =&gt; &#123;</span><br><span class="line">//在发送请求前的额外处理</span><br><span class="line">return config</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service.interceptors.response.use(</span><br><span class="line">res =&gt; &#123;</span><br><span class="line">//响应之后做一些额外操作</span><br><span class="line">return res</span><br><span class="line">&#125;,</span><br><span class="line">error =&gt; &#123;</span><br><span class="line">//在发生错误后的额外处理</span><br><span class="line">return Promise.reject(error)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：</span><br><span class="line">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>
<p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let instance = axios.create(config);</span><br><span class="line">instance.interceptors.request.use(confit=&gt;&#123;</span><br><span class="line">config.headers.token=&quot;sssssss&quot;</span><br><span class="line">return config</span><br><span class="line">&#125;,</span><br><span class="line">error =&gt; &#123;</span><br><span class="line">//在发生错误后的额外处理</span><br><span class="line">return Promise.reject(error)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="取消拦截器"><a href="#取消拦截器" class="headerlink" title="取消拦截器"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let instance = axios.create(config);</span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">config=&gt;&#123;</span><br><span class="line">config.headers.token=&quot;sssssss&quot;</span><br><span class="line">return config</span><br><span class="line">&#125;,</span><br><span class="line">error =&gt; &#123;</span><br><span class="line">//在发生错误后的额外处理</span><br><span class="line">return Promise.reject(error)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">//取消拦截器操作：</span><br><span class="line">axios.interceptors.request.eject(instance)</span><br></pre></td></tr></table></figure>
<h1 id="七、取消请求"><a href="#七、取消请求" class="headerlink" title="七、取消请求"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.CancelToken.source()</span><br><span class="line">axios.get(url,&#123;CancelToken:source,token&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br><span class="line">//触发取消请求：</span><br><span class="line">source.cancel(&#x27;错误信息&#x27;)</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Webpack5搭建一个Vue-Cli</title>
    <url>/2023/03/27/Vue-Cli/</url>
    <content><![CDATA[<p>大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？</p>
<h1 id="1、建一个文件夹"><a href="#1、建一个文件夹" class="headerlink" title="1、建一个文件夹"></a>1、建一个文件夹</h1><p>新建一个文件夹my-vue-cli用来存放项目</p>
<h1 id="2、初始化npm"><a href="#2、初始化npm" class="headerlink" title="2、初始化npm"></a>2、初始化npm</h1><p>在终端中输入 npm init<br>然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包</p>
<h1 id="3、webpack、webpack-cli"><a href="#3、webpack、webpack-cli" class="headerlink" title="3、webpack、webpack-cli"></a>3、webpack、webpack-cli</h1><p>安装 webpack、webpack-cli<br>webpack ：打包的工具<br>webpack-cli ：为webpack提供命令行的工具<br>npm i webpack webpack-cli -D</p>
<h1 id="4、src、public"><a href="#4、src、public" class="headerlink" title="4、src、public"></a>4、src、public</h1><p>在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public/index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;title&gt;my-vue-cli&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/main.js</span><br><span class="line">import &#123; add &#125; from &#x27;./tools/add.js&#x27;</span><br><span class="line">console.log(add(1, 2))</span><br><span class="line">console.log(&#x27;我是main.js&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/tools/add.js</span><br><span class="line">export const add = (a, b) =&gt; &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5、入口文件"><a href="#5、入口文件" class="headerlink" title="5、入口文件"></a>5、入口文件</h1><p>刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。<br>进行入口文件的配置，在根目录下新建 webpack.config.js ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 模式 开发模式</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  // 入口文件 main.js</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &#x27;./src/main.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 输出</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出到 dist文件夹</span><br><span class="line">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">    // js文件下</span><br><span class="line">    filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class="line">    // 每次打包前自动清除旧的dist</span><br><span class="line">    clean: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6、配置打包命令"><a href="#6、配置打包命令" class="headerlink" title="6、配置打包命令"></a>6、配置打包命令</h1><p>到 package.json 里配置打包命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>现在我们到终端输入 npm run build ，就能发现打包成功：<br>但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html<br>小知识：loader和plugin<br>loader ：使webpack拥有解析非js文件的能力，如css、png、ts等等<br>plugin ：拓展webpack的打包功能，如优化体积、显示进度条等等</p>
<h1 id="7、打包html"><a href="#7、打包html" class="headerlink" title="7、打包html"></a>7、打包html</h1><p>打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：<br>npm i html-webpack-plugin -D<br>并且需要在 webpack.config.js 中配置一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 刚刚的代码...</span><br><span class="line">  // 插件都放 plugins 中</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      // 选择模板 public/index.html</span><br><span class="line">      template: &#x27;./public/index.html&#x27;,</span><br><span class="line">      // 打包后的名字</span><br><span class="line">      filename: &#x27;index.html&#x27;,</span><br><span class="line">      // js文件插入 body里</span><br><span class="line">      inject: &#x27;body&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件<br>现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！</p>
<h2 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h2><p>在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在入口文件 main.js 中引入<br>import ‘./styles/index.scss’<br>// 刚刚的代码…<br>我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东<br>sass、sass-loader ：可以将scss代码转成css<br>css-loader ：使webpack具有打包css的能力<br>sass-resources-loader ：可选，支持打包全局公共scss文件<br>mini-css-extract-plugin ：可将css代码打包成一个单独的css文件<br>我们安装一下这些插件<br>npm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D<br>然后配置一下 webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 刚才的代码...</span><br><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 刚才的代码...</span><br><span class="line">  plugins: [</span><br><span class="line">    // 刚才的代码...</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // 将css代码输出到dist/styles文件夹下</span><br><span class="line">      filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class="line">      ignoreOrder: true,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配文件后缀的规则</span><br><span class="line">        test: /\.(css|s[cs]ss)$/,</span><br><span class="line">        use: [</span><br><span class="line">          // loader执行顺序是从右到左</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#x27;css-loader&#x27;,</span><br><span class="line">          &#x27;sass-loader&#x27;,</span><br><span class="line">          // &#123;</span><br><span class="line">          //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class="line">          //   options: &#123;</span><br><span class="line">          //     resources: [</span><br><span class="line">          //       // 放置全局引入的公共scss文件</span><br><span class="line">          //     ],</span><br><span class="line">          //   &#125;,</span><br><span class="line">          // &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：<br>我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.</p>
<h2 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h2><p>webpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  // 引入背景图片</span><br><span class="line">  background-image: url(&#x27;../assets/images/guang.png&#x27;);</span><br><span class="line">  background-size: 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在 webpack.config.js 中添加打包图片的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    // 刚刚的代码...</span><br><span class="line">    &#123;</span><br><span class="line">      // 匹配文件后缀的规则</span><br><span class="line">      test: /\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class="line">      type: &#x27;asset&#x27;,</span><br><span class="line">      parser: &#123;</span><br><span class="line">        // 转base64的条件</span><br><span class="line">        dataUrlCondition: &#123;</span><br><span class="line">           maxSize: 25 * 1024, // 25kb</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      generator: &#123;</span><br><span class="line">        // 打包到 dist/image 文件下</span><br><span class="line">       filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹<br>  我们看一下页面背景图片已经生效，说明打包成功了！</p>
<h2 id="配置babel"><a href="#配置babel" class="headerlink" title="配置babel"></a>配置babel</h2><p>babel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的</p>
<p>首先安装所需的包：<br>@babel/core、babel-loader ：转换语法的工具<br>@babel/preset-env ：转换的一套现成规则<br>@babel/plugin-transform-runtime ：转换async/await所需插件</p>
<p>npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D<br>由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    // 刚刚的代码...</span><br><span class="line">    &#123;</span><br><span class="line">      // 匹配js后缀文件</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      // 排除node_modules中的js</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &#x27;babel-loader&#x27;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// babel.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">presets: [</span><br><span class="line">  // 配置规则</span><br><span class="line">  &quot;@babel/preset-env&quot;</span><br><span class="line">],</span><br><span class="line">// 配置插件</span><br><span class="line">plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了</p>
<h2 id="打包Vue"><a href="#打包Vue" class="headerlink" title="打包Vue"></a>打包Vue</h2><p>打包Vue需要用到以下几个包：<br>vue ：Vue开发所需的依赖<br>vue-loader ：解析 .vue 文件的loader<br>vue-template-compiler ：解析vue中模板的工具<br>@vue/babel-preset-jsx ：支持解析vue中的jsx语法<br>注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本<br>所以我们先安装一下：<br>npm i<br><a href="mailto:&#118;&#117;&#101;&#x40;&#50;&#46;&#54;&#x2e;&#x31;&#52;">&#118;&#117;&#101;&#x40;&#50;&#46;&#54;&#x2e;&#x31;&#52;</a> <a href="mailto:&#x76;&#117;&#x65;&#x2d;&#116;&#x65;&#x6d;&#112;&#108;&#97;&#116;&#101;&#x2d;&#99;&#x6f;&#109;&#112;&#105;&#108;&#x65;&#x72;&#64;&#50;&#46;&#x36;&#x2e;&#49;&#52;">&#x76;&#117;&#x65;&#x2d;&#116;&#x65;&#x6d;&#112;&#108;&#97;&#116;&#101;&#x2d;&#99;&#x6f;&#109;&#112;&#105;&#108;&#x65;&#x72;&#64;&#50;&#46;&#x36;&#x2e;&#49;&#52;</a> <a href="mailto:&#118;&#x75;&#101;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#53;&#46;&#57;&#x2e;&#56;">&#118;&#x75;&#101;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#53;&#46;&#57;&#x2e;&#56;</a> @vue/babel-preset-jsx -D<br>然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 刚才的代码...</span><br><span class="line">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 刚才的代码...</span><br><span class="line">  plugins: [</span><br><span class="line">    // 刚才的代码...</span><br><span class="line">    new VueLoaderPlugin()</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // 刚才的代码...</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        use: &#x27;vue-loader&#x27;,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &quot;@babel/preset-env&quot;,</span><br><span class="line">    // 支持vue中的jsx语法</span><br><span class="line">    &quot;@vue/babel-preset-jsx&quot;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在 src 下新建一个 App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;我是App哈哈哈哈&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  color: #fff;</span><br><span class="line">  background-color: #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>然后改写一下 src/main.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: (h) =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>
<p>此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！</p>
<h2 id="配置路径别名"><a href="#配置路径别名" class="headerlink" title="配置路径别名"></a>配置路径别名</h2><p>有时候文件引用搁着太多层，引用起来会看起来很不明确，比如<br>../../../../../App.vue ，所以我们可以配置一下别名 alia</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 刚才的代码...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 路径别名</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class="line">      assets: &#x27;~/assets&#x27;,</span><br><span class="line">      tools: &#x27;~/tools&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 引入文件时省略后缀</span><br><span class="line">    extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在别名配置完成啦：<br>配置前： ../../../../../App.vue<br>配置后： @/App.vue</p>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server</p>
<p>npm i webpack-dev-server -D<br>到 webpack.config.js 中配置 devServer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  // 自定义端口号</span><br><span class="line">  // port:7000,</span><br><span class="line">  // 自动打开浏览器</span><br><span class="line">  open: true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>然后到 package.json 中配置一下启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;serve&quot;: &quot;webpack serve&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>此时我们运行 npm run serve 就可以启动项目啦！</p>
<h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><p>我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件<br>webpack.base.js ：两个环境共用配置<br>入口，输出配置<br>各种文件的处理<br>进度条展示<br>路径别名<br>webpack.dev.js ：开发环境独有配置<br>webpack-dev-server<br>不同的source-map模式<br>不同的环境变量<br>webpack.prod.js ：生产环境独有配置<br>不同的source-map模式<br>不同的环境变量<br>我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置<br>npm i webpack-merge -D<br>然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 公共配置</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">// 入口文件 main.js</span><br><span class="line">entry: &#123;</span><br><span class="line">  main: &#x27;./src/main.js&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">// 输出</span><br><span class="line">output: &#123;</span><br><span class="line">  // 输出到 dist文件夹</span><br><span class="line">  // 记得改路径</span><br><span class="line">  path: path.resolve(__dirname, &#x27;../dist&#x27;),</span><br><span class="line">  // js文件下</span><br><span class="line">  filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class="line">  // 每次打包前自动清除旧的dist</span><br><span class="line">  clean: true,</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    // 选择模板 public/index.html</span><br><span class="line">    template: &#x27;./public/index.html&#x27;,</span><br><span class="line">    // 打包后的名字</span><br><span class="line">    filename: &#x27;index.html&#x27;,</span><br><span class="line">    // js文件插入 body里</span><br><span class="line">    inject: &#x27;body&#x27;,</span><br><span class="line">  &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">    // 将css代码输出到dist/styles文件夹下</span><br><span class="line">    filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class="line">    ignoreOrder: true,</span><br><span class="line">  &#125;),</span><br><span class="line">  new VueLoaderPlugin()</span><br><span class="line">],</span><br><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      // 匹配文件后缀的规则</span><br><span class="line">      test: /\.(css|s[cs]ss)$/,</span><br><span class="line">      use: [</span><br><span class="line">        // loader执行顺序是从右到左</span><br><span class="line">        MiniCssExtractPlugin.loader,</span><br><span class="line">        &#x27;css-loader&#x27;,</span><br><span class="line">        &#x27;sass-loader&#x27;,</span><br><span class="line">        // &#123;</span><br><span class="line">        //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class="line">        //   options: &#123;</span><br><span class="line">        //     resources: [</span><br><span class="line">        //       // 放置全局引入的公共scss文件</span><br><span class="line">        //     ],</span><br><span class="line">        //   &#125;,</span><br><span class="line">        // &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      // 匹配文件后缀的规则</span><br><span class="line">      test: /\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class="line">      type: &#x27;asset&#x27;,</span><br><span class="line">      parser: &#123;</span><br><span class="line">        // 转base64的条件</span><br><span class="line">        dataUrlCondition: &#123;</span><br><span class="line">          maxSize: 25 * 1024, // 25kb</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      generator: &#123;</span><br><span class="line">        // 打包到 dist/image 文件下</span><br><span class="line">        filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      // 排除node_modules中的js</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &#x27;babel-loader&#x27;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.vue$/,</span><br><span class="line">      use: &#x27;vue-loader&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  // 路径别名</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class="line">    assets: &#x27;~/assets&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 引入文件时省略后缀</span><br><span class="line">  extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack.dev.js</span><br><span class="line">// 开发环境</span><br><span class="line">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">mode: &#x27;development&#x27;,</span><br><span class="line">devServer: &#123;</span><br><span class="line">  open: true,</span><br><span class="line">  // hot: true,</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack.prod.js</span><br><span class="line">// 生产环境</span><br><span class="line">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">mode: &#x27;production&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们到 package.json 修改一下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;webpack serve --config ./build/webpack.dev&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack --config ./build/webpack.prod&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>接下来我们运行这两个命令，发现都成功了：<br>npm run build<br>npm run serve</p>
<h2 id="构建进度条"><a href="#构建进度条" class="headerlink" title="构建进度条"></a>构建进度条</h2><p>无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin</p>
<p>npm i progress-bar-webpack-plugin -D</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line">// 刚刚的代码...</span><br><span class="line">const ProgressBarPlugin = require(&#x27;progress-bar-webpack-plugin&#x27;)</span><br><span class="line">const chalk = require(&#x27;chalk&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 刚刚的代码...</span><br><span class="line">  plugins: [</span><br><span class="line">    // 刚刚的代码...</span><br><span class="line">    new ProgressBarPlugin(&#123;</span><br><span class="line">      format: ` build [:bar] $&#123;chalk.green.bold(&#x27;:percent&#x27;)&#125; (:elapsed seconds)`,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  // 刚刚的代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到无论启动项目或者打包，都会有进度条了</p>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>source-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：<a href="https://webpack.docschina.org/">https://webpack.docschina.org</a>…</p>
<p>这里我使用两种模式：<br>development ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小<br>production ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式<br>所以我们开始配置 source-map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack.dev.js</span><br><span class="line">// 刚才的代码...</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">// 刚才的代码...</span><br><span class="line">devtool: &#x27;eval-cheap-module-source-map&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">webpack.prod.js</span><br><span class="line">// 刚才的代码...</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">// 刚才的代码...</span><br><span class="line">devtool: &#x27;nosources-source-map&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置 devlopment、production 这两个环境的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack.dev.js</span><br><span class="line">// 刚才的代码...</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">// 刚才的代码...</span><br><span class="line">plugins: [</span><br><span class="line">  // 定义全局变量</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">    process: &#123;</span><br><span class="line">      env: &#123;</span><br><span class="line">        NODE_DEV: JSON.stringify(&#x27;development&#x27;),</span><br><span class="line">        // 这里可以定义你的环境变量</span><br><span class="line">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack.prod.js</span><br><span class="line">// 刚才的代码...</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = merge(base, &#123;</span><br><span class="line">// 刚才的代码...</span><br><span class="line">plugins: [</span><br><span class="line">  // 定义全局变量</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">    process: &#123;</span><br><span class="line">      env: &#123;</span><br><span class="line">        NODE_DEV: JSON.stringify(&#x27;prodction&#x27;),</span><br><span class="line">        // 这里可以定义你的环境变量</span><br><span class="line">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 + Vite + TS项目引入iconfont图标（Svg方式）</title>
    <url>/2023/05/06/Vue3%20+%20Vite%20+%20TS%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5iconfont%E5%9B%BE%E6%A0%87%EF%BC%88Svg%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="🍻-前言"><a href="#🍻-前言" class="headerlink" title="🍻 前言"></a>🍻 前言</h1><p>每一个项目都避免不了使用各种各样的图标，如果我们使用了 UI 组件库，比如说 ELement 等，那么组件库有一些封装好的图标供我们使用。但是项目是多变的和复杂的，组件库提供的图标很多时候不能满足需求，这个时候就需要我们自己引入想要的图标了。<br>今天介绍的便是如何将 iconfont 阿里图标库的图标引入到我们的 Vue3 项目中来！</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vite-plugin-svg-icons -D</span><br></pre></td></tr></table></figure>
<h1 id="引入-iconfont"><a href="#引入-iconfont" class="headerlink" title="引入 iconfont"></a>引入 iconfont</h1><h2 id="封装-svg-icon-组件"><a href="#封装-svg-icon-组件" class="headerlink" title="封装 svg-icon 组件"></a>封装 svg-icon 组件</h2><p>我们在 iconfont 官网上可以看到给出了 symbol 引用示例，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>上段代码就是图标的具体使用方式，如果我们每次都按照上面的方式使用，那么无疑是很麻烦的，我们不妨将上面的代码封装为一个组件。在需要用到图标的地方直接引入我们的组件即可了。<br>在 components 目录下新建 SvgIcon 目录，然后新建 SvgIcon.vue 文件。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// src/components/SvgIcon/SvgIcon.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href=&quot;iconClassName&quot; :fill=&quot;color&quot; /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  iconName: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  className: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  color: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;#409eff&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 图标在 iconfont 中的名字</span><br><span class="line">const iconClassName = computed(()=&gt;&#123;</span><br><span class="line">  return `#$&#123;props.iconName&#125;`;</span><br><span class="line">&#125;)</span><br><span class="line">// 给图标添加上类名</span><br><span class="line">const svgClass = computed(() =&gt; &#123;</span><br><span class="line">  if (props.className) &#123;</span><br><span class="line">    return `svg-icon $&#123;props.className&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#x27;svg-icon&#x27;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.svg-icon &#123;</span><br><span class="line">  width: 1em;</span><br><span class="line">  height: 1em;</span><br><span class="line">  position: relative;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">  vertical-align: -2px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>组件封装好后我们还需要全局注册一下，不然每次引用图标的时候还得单独引入一次该组件。所以我们就在 main.ts 里面全局注册一下。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import SvgIcon from &#x27;./components/SvgIcon/SvgIcon.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.component(&#x27;SvgIcon&#x27;, SvgIcon);</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="使用iconfont"><a href="#使用iconfont" class="headerlink" title="使用iconfont"></a>使用iconfont</h2><p>接下来我们就需要去 iconfont 官网了，新建一个 iconfont 资源库，存放自己的 iconfont。<br>我们选中 symbol 模式，这里我介绍三种引入方式。<br>第一种：<br>直接在线引入官网提供的在线 js 地址，我们直接以 script 标签的形式引入即可。这种方式最为简单，但是也有不好的一点，需要用户有网络环境，而且得保证 iconfont 网站没有崩掉。<br>第二种：<br>直接下载至本地，我们从官网直接将代码下载下来，然后放到我们项目中引用，也是可以的。不过这种方式稍显麻烦，每次更新图标库之后都得重新下载一遍。<br>第三种：<br>这也是我比较喜欢的方式，也就是将在线地址中的代码直接复制粘贴到我们项目中来，这种方式最为简单，每次更新图标库之后只需要重新复制一下代码即可。这里我们也将采用这种方式。<br>具体使用：<br>在项目 assets 目录下新建 iconfont 目录，在该目录下新建 iconfont.js 文件，然后将 iconfont 在线地址中提供的代码全部复制过来。<br>然后在 main.ts 中引入 iconfont.js。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import SvgIcon from &#x27;./components/SvgIcon/SvgIcon.vue&#x27;</span><br><span class="line">import &#x27;./assets/iconfont/iconfont.js&#x27;;</span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.component(&#x27;SvgIcon&#x27;, SvgIcon);</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>引入 iconfont 得过程非常简单，主要分为了以下两步：</p>
<ul>
<li>封装 svg-icon 组件</li>
<li>引入 iconfont 生成的 js 代码</li>
</ul>
<p>接下来我们就实际使用试试，我们就直接在 App.vue 中引入几个图标试试。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class="line">  &lt;svg-icon iconName=&quot;icon-gongzuoleixing&quot;&gt;&lt;/svg-icon&gt;</span><br><span class="line">  &lt;svg-icon iconName=&quot;icon-yulan&quot; className=&quot;yulan&quot;&gt;&lt;/svg-icon&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我们的图标已经可以使用了，其中 iconName 属性值就是我们在 iconfont 网站复制的 iconfont 的名称代码。如果想要该颜色或大小，可以自行传入一个类或者 color 属性。<br>除此之外，如果你有自己下载好的 svg 文件，那么也是可以通过上面方式引入的，只需要将 iconName 改为你自己本地的 svg 名称即可。</p>
<h1 id="图标自动管理（必看）"><a href="#图标自动管理（必看）" class="headerlink" title="图标自动管理（必看）"></a>图标自动管理（必看）</h1><p>即使使用了symbol方式，当设计小姐姐新增图标时，我们还是无法避免重新生成图标代码。那么有没有更优雅的解决方案呢？<br>答案是有的。svg-sprite-loader + require.context。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>支持多色图标了，不再受单色限制。</li>
<li>支持丰富的css属性进行定制。</li>
<li>兼容性较差，支持 ie9+,及现代浏览器。</li>
<li>浏览器渲染svg的性能一般，还不如png。</li>
</ul>
]]></content>
      <categories>
        <category>vite</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-搜索引擎SEO优化</title>
    <url>/2023/04/05/Vue-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ESEO%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>众所周知，Vue SPA 单页应用对 SEO 不友好，当然也有相应的解决方案。</p>
<h1 id="1-SSR-服务器渲染"><a href="#1-SSR-服务器渲染" class="headerlink" title="1. SSR 服务器渲染"></a>1. SSR 服务器渲染</h1><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将他们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。<br>服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>
<h2 id="权衡之处："><a href="#权衡之处：" class="headerlink" title="权衡之处："></a>权衡之处：</h2><ul>
<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数（lifecyle hook）中使用；一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。</li>
<li>环境和部署要求更高，需要 Node.js server 运行环境。</li>
<li>高流量的情况下，请准备相应的服务器负载，并明智的采用缓存策略。<h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2></li>
<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li>
<li>更快的内容到达时间（time-to-content），特别是对于换忙的网络情况或运行缓慢的设备。</li>
</ul>
<h2 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h2><ul>
<li>一套代码两套执行环境，会引起各种问题，比如服务端没有 window、document 对象，处理方式是增加判断，如果是客户端才执行。</li>
<li>引用 npm 包，带有 dom 操作的，例如：wowjs，不能用 import 的方式。</li>
<li>Nuxt asyncData 方法，初始化页面前先得到数据，但仅限于页面组件调用。</li>
</ul>
<h1 id="2-Nuxt-静态化"><a href="#2-Nuxt-静态化" class="headerlink" title="2. Nuxt 静态化"></a>2. Nuxt 静态化</h1><p>Nuxt.js 框架，官方是这样介绍的，从头搭建一个服务端渲染的应用是相当复杂的，幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来作为静态站点生成器。<br>静态化是 Nuxt.js 打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br>如果你的动态路由参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有 id，然后打包时遍历 id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。</p>
<h2 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>纯静态文件，访问速度超快。</li>
<li>对比 SSR，不涉及到服务器负载方面问题。</li>
<li>静态网页不宜遭到黑客攻击，安全性更高。<h2 id="不足：-1"><a href="#不足：-1" class="headerlink" title="不足："></a>不足：</h2></li>
<li>如果动态路由参数多的话不适用。</li>
</ul>
<h1 id="3-预渲染-prerender-spa-plugin"><a href="#3-预渲染-prerender-spa-plugin" class="headerlink" title="3. 预渲染 prerender-spa-plugin"></a>3. 预渲染 prerender-spa-plugin</h1><p>如果你只是用来改善少数营销页面（例如 /about，/contact等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时（build time）简单的生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p>
<h2 id="优势：-2"><a href="#优势：-2" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>改动小，引入插件配置即可<h2 id="不足：-2"><a href="#不足：-2" class="headerlink" title="不足："></a>不足：</h2></li>
<li>无法使用动态路由</li>
<li>只适用少量页面的项目，页面多达几百个的情况下，打包回非常慢。</li>
</ul>
<h1 id="4-使用-Phantomjs-针对爬虫做处理"><a href="#4-使用-Phantomjs-针对爬虫做处理" class="headerlink" title="4. 使用 Phantomjs 针对爬虫做处理"></a>4. 使用 Phantomjs 针对爬虫做处理</h1><p>Phantomjs 是一个基于 webkit 内核的无头浏览器，即没有 UI 界面，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“Phantomjs 宣布终止开发”，但是已经满足对 Vue 的 SEO 处理。<br>这种解决方案其实是一种旁路机制，原理就是通过 Nginx 配置，判断访问的来源 UA 是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个 node serve，在通过 Phantomjs 来解析完整的 HTML，返回给爬虫。</p>
<h2 id="优势：-3"><a href="#优势：-3" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>完全不用改动项目代码，按原本的 SPA 开发即可，对比开发 SSR 成本小不要太多。</li>
<li>对已用 SPA 开发完成的项目，可以直接使用。<h2 id="不足：-3"><a href="#不足：-3" class="headerlink" title="不足："></a>不足：</h2></li>
<li>部署需要 node 服务器支持。</li>
<li>爬虫访问比网页访问要慢一些，因为要定时资源加载完成才返回给爬虫。</li>
<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决办法是判断访问的 IP，是否是百度官方爬虫的 IP。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果构建大型网站，如商场类，别犹豫，直接上 SSR 服务器渲染，当然也有相应的坑等你，不过社区比较成熟，英文过关，一切问题都可以解决。<br>如果只是个人博客、公司官网的项目，其余三种都可以。<br>如果对已用 SPA 开发完成的项目进行 SEO 优化，而且支持 node 服务器，请使用 Phantomjs。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3:Pinia使用</title>
    <url>/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p>
<h1 id="什么是-Pinia"><a href="#什么是-Pinia" class="headerlink" title="什么是 Pinia"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p>
<h1 id="Pinia-的优点"><a href="#Pinia-的优点" class="headerlink" title="Pinia 的优点"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>Pinia 中文网：<a href="https://pinia.web3doc.top/">https://pinia.web3doc.top/</a></p>
<h1 id="Pinia-安装"><a href="#Pinia-安装" class="headerlink" title="Pinia 安装"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="Pinia-使用"><a href="#Pinia-使用" class="headerlink" title="Pinia 使用"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p>
<h2 id="1-Pinia-导入"><a href="#1-Pinia-导入" class="headerlink" title="1.Pinia 导入"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;createPinia&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>
<p>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;PiniaVuePlugin&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>
<p>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const state = createPinia()</span><br></pre></td></tr></table></figure>
<p>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(state)</span><br></pre></td></tr></table></figure>
<h2 id="2-Pinia-基本使用"><a href="#2-Pinia-基本使用" class="headerlink" title="2.Pinia 基本使用"></a>2.Pinia 基本使用</h2><h3 id="1-创建-index-ts-文件"><a href="#1-创建-index-ts-文件" class="headerlink" title="1.创建 index.ts 文件"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p>
<h3 id="2-编写-index-ts-文件"><a href="#2-编写-index-ts-文件" class="headerlink" title="2.编写 index.ts 文件"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &quot;pinia&quot;;</span><br></pre></td></tr></table></figure>
<p>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const enum Names &#123;</span><br><span class="line">  TEST = &quot;TEST&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br>这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="3-修改-Pinia-的值"><a href="#3-修改-Pinia-的值" class="headerlink" title="3.修改 Pinia 的值"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p>
<h4 id="方式一：直接修改"><a href="#方式一：直接修改" class="headerlink" title="方式一：直接修改"></a>方式一：直接修改</h4><p><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="方式二：-patch-函数修改"><a href="#方式二：-patch-函数修改" class="headerlink" title="方式二：$patch 函数修改"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="方式三：-patch-函数修改"><a href="#方式三：-patch-函数修改" class="headerlink" title="方式三：$patch 函数修改"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>效果其实和方式二是一模一样的</p>
<h4 id="方式四：-state-方式"><a href="#方式四：-state-方式" class="headerlink" title="方式四：$state 方式"></a>方式四：$state 方式</h4><p><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="方式五：-action-方式"><a href="#方式五：-action-方式" class="headerlink" title="方式五： action 方式"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p>
<h1 id="pinia-解构"><a href="#pinia-解构" class="headerlink" title="pinia 解构"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>
<p>然后把我们解构的对象包裹一下就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; name, age &#125; = storeToRefs(userInfo)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="Pinia-的-actions"><a href="#Pinia-的-actions" class="headerlink" title="Pinia 的 actions"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="getter-函数"><a href="#getter-函数" class="headerlink" title="getter 函数"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="API-的使用"><a href="#API-的使用" class="headerlink" title="API 的使用"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>然后我们点一下$reset按钮，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>控制台打印出监听到的变化结果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>$onAction：一调用 actions 就触发<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>控制台打印出监听到的变化结果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3setup函数</title>
    <url>/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="vue2-和-vue3-开发的区别"><a href="#vue2-和-vue3-开发的区别" class="headerlink" title="vue2 和 vue3 开发的区别"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p>
<p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p>
<h1 id="使用-setup-原因"><a href="#使用-setup-原因" class="headerlink" title="使用 setup 原因"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p>
<p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p>
<h1 id="setup-用法"><a href="#setup-用法" class="headerlink" title="setup 用法"></a>setup 用法</h1><ol>
<li>setup 函数是组合式 API 的入口。</li>
<li>setup 函数是启动页面后自动执行的函数。</li>
<li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li>
<li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li>
<li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li>
</ol>
<h1 id="setup-可以接受哪些参数"><a href="#setup-可以接受哪些参数" class="headerlink" title="setup 可以接受哪些参数"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p>
<h1 id="setup-函数定义变量"><a href="#setup-函数定义变量" class="headerlink" title="setup 函数定义变量"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p>
<h2 id="定义一个基本类型变量"><a href="#定义一个基本类型变量" class="headerlink" title="定义一个基本类型变量"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>同样，创建其他基本类型也是一样的编写方式。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="setup-创建复杂数据类型"><a href="#setup-创建复杂数据类型" class="headerlink" title="setup 创建复杂数据类型"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>刷新页面，渲染正常<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="setup-创建方法"><a href="#setup-创建方法" class="headerlink" title="setup 创建方法"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p>
<h2 id="第一种就是很常见的通过-function-的方式创建"><a href="#第一种就是很常见的通过-function-的方式创建" class="headerlink" title="第一种就是很常见的通过 function 的方式创建"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code>// 一、通过 function 的方式创建
    function btn() &#123;
        console.log(&#39;按钮被点击了&#39;)
    &#125;
</code></pre>
<h2 id="另一种使用过箭头函数的方式创建"><a href="#另一种使用过箭头函数的方式创建" class="headerlink" title="另一种使用过箭头函数的方式创建"></a>另一种使用过箭头函数的方式创建</h2><pre><code>  // 二、通过箭头函数的方式创建
  const btn = () =&gt; &#123;
    console.log(&#39;按钮被点击了&#39;)
  &#125;
</code></pre>
<p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3toRef和toRefs函数</title>
    <url>/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="toRef-函数"><a href="#toRef-函数" class="headerlink" title="toRef 函数"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p>
<p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>
<h1 id="toRef-函数使用"><a href="#toRef-函数使用" class="headerlink" title="toRef 函数使用"></a>toRef 函数使用</h1><h2 id="首先呢，-toRef-函数有两个参数"><a href="#首先呢，-toRef-函数有两个参数" class="headerlink" title="首先呢， toRef 函数有两个参数"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p>
<h2 id="接下来我们使用-toRef-函数写一个案例"><a href="#接下来我们使用-toRef-函数写一个案例" class="headerlink" title="接下来我们使用 toRef 函数写一个案例"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>然后点击按钮看一下页面效果<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>
<h1 id="ref-函数验证"><a href="#ref-函数验证" class="headerlink" title="ref 函数验证"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p>
<h1 id="toRefs-函数"><a href="#toRefs-函数" class="headerlink" title="toRefs 函数"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p>
<h1 id="toRefs-函数使用"><a href="#toRefs-函数使用" class="headerlink" title="toRefs 函数使用"></a>toRefs 函数使用</h1><p><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src="/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>查看效果<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3shallowRef和shallowReactive</title>
    <url>/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/</url>
    <content><![CDATA[<h1 id="shallowRef-和-shallowReactive"><a href="#shallowRef-和-shallowReactive" class="headerlink" title="shallowRef 和 shallowReactive"></a>shallowRef 和 shallowReactive</h1><ol>
<li>shallowRef 函数，只处理基本类型数据。</li>
<li>shallowReactive 函数，只处理第一层数据。</li>
<li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li>
</ol>
<h1 id="深度监听的问题："><a href="#深度监听的问题：" class="headerlink" title="深度监听的问题："></a>深度监听的问题：</h1><ol>
<li>无论 ref 函数还是 reactive 函数都是深度监听。</li>
<li>如果数据量过大，超级超级消耗性能。</li>
<li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li>
</ol>
<h1 id="使用-shallowReactive-非深度监听"><a href="#使用-shallowReactive-非深度监听" class="headerlink" title="使用 shallowReactive 非深度监听"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们分别点击两个按钮，看一下页面变化。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>通过效果，我们稍微总结一下：</p>
<ol>
<li>shallowReactive只会包装第一层的数据</li>
<li>默认情况它只能够监听数据的第一层。</li>
<li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li>
</ol>
<h1 id="使用-shallowRef-非深度监听"><a href="#使用-shallowRef-非深度监听" class="headerlink" title="使用 shallowRef 非深度监听"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>点击按钮，修改 boy 的值<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3侦听器watch</title>
    <url>/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/</url>
    <content><![CDATA[<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p>
<h1 id="watch-侦听器使用"><a href="#watch-侦听器使用" class="headerlink" title="watch 侦听器使用"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p>
<p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p>
<p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p>
<h1 id="侦听器监听-reactive"><a href="#侦听器监听-reactive" class="headerlink" title="侦听器监听 reactive"></a>侦听器监听 reactive</h1><p><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>发现点击之后没有监听到<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>这个时候就可以加上 deep 深度监听。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>加上深度监听 { deep:true }<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p>
<p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>监听多个参数执行相同逻辑<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>修改 name 和 age 的值<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3封装打字机效果组件</title>
    <url>/2023/05/09/Vue3%E5%B0%81%E8%A3%85%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="「摘要」"><a href="#「摘要」" class="headerlink" title="「摘要」"></a>「摘要」</h1><p>最近在做项目中有这样一个需求，就是需要实现一个打字机效果。当然打字机效果可以自己编写，使用css来实现，等等。为了不影响项目进度，便于日常好维护。决定找一找其他方式，经过查阅资料，翻看了各种资料之后，发现了TypeIt。</p>
<h1 id="「typeit介绍」"><a href="#「typeit介绍」" class="headerlink" title="「typeit介绍」"></a>「typeit介绍」</h1><p>typeit是一款轻量级打字机特效插件。该打印机特效可以设置打字速度，是否显示光标，是否换行和延迟时间等属性，它可以打印单行文本和多行文本，并具有可缩放、响应式等特点。</p>
<h1 id="「安装typeit」"><a href="#「安装typeit」" class="headerlink" title="「安装typeit」"></a>「安装typeit」</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm add typeit</span><br><span class="line">npm install typeit</span><br></pre></td></tr></table></figure>
<h1 id="「配置项说明」"><a href="#「配置项说明」" class="headerlink" title="「配置项说明」"></a>「配置项说明」</h1><p><img src="/2023/05/09/Vue3%E5%B0%81%E8%A3%85%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E7%BB%84%E4%BB%B6/%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="「官网使用示例」"><a href="#「官网使用示例」" class="headerlink" title="「官网使用示例」"></a>「官网使用示例」</h1><p>在官网我们就可以看出是如何使用的，通过.的方式来实现打字机效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;hero&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new TypeIt(&quot;#hero&quot;, &#123;</span><br><span class="line">  speed: 50,</span><br><span class="line">  startDelay: 900,</span><br><span class="line">&#125;)</span><br><span class="line">  .type(&quot;the mot versti&quot;, &#123; delay: 100 &#125;)</span><br><span class="line">  .move(-8, &#123; delay: 100 &#125;)</span><br><span class="line">  .type(&quot;s&quot;, &#123; delay: 400 &#125;)</span><br><span class="line">  .move(null, &#123; to: &quot;START&quot;, instant: true, delay: 300 &#125;)</span><br><span class="line">  .move(1, &#123; delay: 200 &#125;)</span><br><span class="line">  .delete(1)</span><br><span class="line">  .type(&quot;T&quot;, &#123; delay: 225 &#125;)</span><br><span class="line">  .pause(200)</span><br><span class="line">  .move(2, &#123; instant: true &#125;)</span><br><span class="line">  .pause(200)</span><br><span class="line">  .move(5, &#123; instant: true &#125;)</span><br><span class="line">  .move(5, &#123; delay: 200 &#125;)</span><br><span class="line">  .type(&quot;a&quot;, &#123; delay: 350 &#125;)</span><br><span class="line">  .move(null, &#123; to: &quot;END&quot; &#125;)</span><br><span class="line">  .type(&quot;le typing utlity&quot;)</span><br><span class="line">  .move(-4, &#123; delay: 150 &#125;)</span><br><span class="line">  .type(&quot;i&quot;)</span><br><span class="line">  .move(null, &#123; to: &quot;END&quot; &#125;)</span><br><span class="line">  .type(&#x27; on the &lt;span class=&quot;place&quot;&gt;internet&lt;/span&gt;&#x27;, &#123; delay: 400 &#125;)</span><br><span class="line">  .delete(&quot;.place&quot;, &#123; delay: 800, instant: true &#125;)</span><br><span class="line">  .type(&#x27;&lt;em&gt;&lt;strong class=&quot;font-semibold&quot;&gt;planet.&lt;/strong&gt;&lt;/em&gt;&#x27;, &#123;</span><br><span class="line">    speed: 100,</span><br><span class="line">  &#125;)</span><br><span class="line">  .go();</span><br></pre></td></tr></table></figure>
<p>根据上面我们掌握，了解到的信息，接下来我们使用typeit实现打字机效果，来实践一下。<br>首先我们使用vite初始化项目，初始化过程这里就省略不做详细说明。</p>
<h1 id="「创建组件目录」"><a href="#「创建组件目录」" class="headerlink" title="「创建组件目录」"></a>「创建组件目录」</h1><p>在components目录下创建一个typeit文件夹，再创建index.ts文件。</p>
<h1 id="「封装组件」"><a href="#「封装组件」" class="headerlink" title="「封装组件」"></a>「封装组件」</h1><p>接下来我们要在刚刚新创建的index.ts文件里，封装组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import TypeIt from &#x27;typeit&#x27;</span><br><span class="line">import &#123; defineComponent, h &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &#x27;TypeIt&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /** 打字速度，以每一步之间的毫秒数为单位 */</span><br><span class="line">    speed: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 200,</span><br><span class="line">    &#125;,</span><br><span class="line">    values: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      default: [],</span><br><span class="line">    &#125;,</span><br><span class="line">    className: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;type-it&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    cursor: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    return h(</span><br><span class="line">      &#x27;span&#x27;,</span><br><span class="line">      &#123;</span><br><span class="line">        class: this.className,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        default: () =&gt; [],</span><br><span class="line">      &#125;,</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    new (TypeIt as any)(`.$&#123;this.className&#125;`, &#123;</span><br><span class="line">      strings: this.values,</span><br><span class="line">      speed: this.speed,</span><br><span class="line">      cursor: this.cursor,</span><br><span class="line">      breakLines: false,</span><br><span class="line">      loop: true</span><br><span class="line">    &#125;).go()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="「使用组件」"><a href="#「使用组件」" class="headerlink" title="「使用组件」"></a>「使用组件」</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;index-title&quot;&gt;</span><br><span class="line">        &lt;h2 class=&quot;outline-none&quot;&gt;</span><br><span class="line">            &lt;TypeIt :values=&quot;title&quot; :cursor=&quot;false&quot; :speed=&quot;150&quot; /&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import TypeIt from &#x27;@/components/typeit&#x27;</span><br><span class="line"></span><br><span class="line">const title = [</span><br><span class="line">    &quot;陋室铭 -刘禹锡[唐代]&quot;,</span><br><span class="line">    &quot;山不在高，有仙则名。&quot; ,</span><br><span class="line">    ……</span><br><span class="line">    ]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3计算属性</title>
    <url>/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="computed-计算属性说明"><a href="#computed-计算属性说明" class="headerlink" title="computed 计算属性说明"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p>
<h1 id="计算属性使用"><a href="#计算属性使用" class="headerlink" title="计算属性使用"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们编写一个案例<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li>
<li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li>
<li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li>
<li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li>
<li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li>
<li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2023/04/05/Vuex/</url>
    <content><![CDATA[<p>Vuex它是一个程序里面的状态管理模式，它是集中式存储所有组件的状态的小仓库，并且保持我们存储的状态以一种可以预测的方式发生变化。</p>
<h1 id="第一步，了解Vuex"><a href="#第一步，了解Vuex" class="headerlink" title="第一步，了解Vuex"></a>第一步，了解Vuex</h1><h2 id="问题假设"><a href="#问题假设" class="headerlink" title="问题假设:"></a>问题假设:</h2><p>如果你的项目里有很多页面（组件/视图），页面之间存在多级的嵌套关系，此时，这些页面假如都需要共享一个状态的时候，此时就会产生以下两个问题：</p>
<ol>
<li>多个视图依赖同一个状态</li>
<li>来自不同视图的行为需要变更同一个状态<h2 id="解决以上方法的方案-🤪"><a href="#解决以上方法的方案-🤪" class="headerlink" title="解决以上方法的方案:🤪"></a>解决以上方法的方案:🤪</h2></li>
<li>对于第一个问题:</li>
</ol>
<ul>
<li>假如是多级嵌套关系，你可以使用父子组件传参进行解决；</li>
<li>对于兄弟组件或者关系更复杂组件之间，就很难办了，虽然可以通过各种各样的办法解决，可实在很不优雅，而且项目是越做越大，代码就会变得越多。</li>
</ul>
<ol start="2">
<li>对于第二个问题：</li>
</ol>
<ul>
<li>你可以通过父子组件直接引用，或者通过事件来变更或者同步状态的多份拷贝，这种模式很脆弱，往往使得代码难以维护，而且同样会让代码就会变得越多。<h2 id="不如换一种思路："><a href="#不如换一种思路：" class="headerlink" title="不如换一种思路："></a>不如换一种思路：</h2></li>
<li>把各个组件都需要依赖的同一个状态抽取出来，在全局使用进行管理。</li>
<li>在这种模式下，任何组件都可以直接访问到这个状态，或者当状态发生改变时，所有的组件都获得更新。<h2 id="这时候，就要用到Vuex"><a href="#这时候，就要用到Vuex" class="headerlink" title="这时候，就要用到Vuex"></a>这时候，就要用到Vuex</h2>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的数据响应机制来进行高效的状态更新。<h2 id="vuex使用周期图"><a href="#vuex使用周期图" class="headerlink" title="vuex使用周期图"></a>vuex使用周期图</h2><img src="/2023/04/05/Vuex/vuex.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><h2 id="那什么时候应该用vuex呢？🤔"><a href="#那什么时候应该用vuex呢？🤔" class="headerlink" title="那什么时候应该用vuex呢？🤔"></a>那什么时候应该用vuex呢？🤔</h2></li>
<li>如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。</li>
<li>假如你的项目达到了中大型应用的规模，此时你很可能会考虑，如何更好地在组件外部管理状态，Vuex将会成为你的选择。<h1 id="第二步，安装vuex"><a href="#第二步，安装vuex" class="headerlink" title="第二步，安装vuex"></a>第二步，安装vuex</h1></li>
</ul>
<ol>
<li>首先，安装vuex<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure></li>
<li>然后配置vuex，在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">// 定义一个name，以供全局使用</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wnxx&#x27;</span>,</span><br><span class="line">    <span class="comment">// 定义一个number，以供全局使用</span></span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 定义一个list，以供全局使用</span></span><br><span class="line">    <span class="attr">list</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;welcome&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;to&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;vuex&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li>
<li>修改main.js：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入我们前面导出的store对象</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>; </span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store, <span class="comment">// 把store对象添加到vue实例上</span></span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">App</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>最后修改App.vue：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用this.$store.state.XXX可以直接访问到仓库中的状态</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
此时，启动项目,即可在控制台输出刚才我们定义在store中的name的值。<h2 id="官方建议1"><a href="#官方建议1" class="headerlink" title="官方建议1:"></a>官方建议1:</h2>官方建议我们以上操作this.$store.state.XXX最好放在计算属性中，就像这样：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">getName</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="官方建议2"><a href="#官方建议2" class="headerlink" title="官方建议2:"></a>官方建议2:</h2>是不是每次都写this.$store.state.XXX让你感到繁琐，你实在不想写，当然有简便的写法，就像下面这样：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">// 从vuex中导入mapState</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它</span></span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;name&#x27;</span>]), </span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
你甚至可以在解构的时候给它赋别名，取外号，就像这样：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class="line">...<span class="title function_">mapState</span>(&#123; <span class="attr">aliasName</span>: <span class="string">&#x27;name&#x27;</span> &#125;),  </span><br></pre></td></tr></table></figure>
🤗现在，安装vuex并且初始化的工作就结束了，此时你可以很轻易的在项目的任意地方访问到仓库里的状态。<h1 id="第三步，了解修饰器：Getter"><a href="#第三步，了解修饰器：Getter" class="headerlink" title="第三步，了解修饰器：Getter"></a>第三步，了解修饰器：Getter</h1>接下来，我们介绍一个读取操作的 “修饰利器” —Getter<h2 id="问题假设-1"><a href="#问题假设-1" class="headerlink" title="问题假设:"></a>问题假设:</h2>😡设想，你已经将store中的name展示到页面上了，而且是很多页面都展示了，此时产品经理要求：所有的name前面都要加上“hello”！<br>这时候，你第一想到的是怎么加呢？<br>emm…在每个页面上，使用this.$store.state.name获取到值之后，进行遍历，前面追加”hello”即可。<br>No,No,No<h2 id="这样很不好，原因如下："><a href="#这样很不好，原因如下：" class="headerlink" title="这样很不好，原因如下："></a>这样很不好，原因如下：</h2></li>
</ol>
<ul>
<li>第一，假如你在A、B、C三个页面都用到了name，那么你要在这A、B、C三个页面都修改一遍，多个页面你就要加很多遍这个方法，这样只会造成代码冗余；</li>
<li>第二，假如下次产品经理让你把 “hello” 改成 “GoodBye” 的时候，你又得把三个页面都改一遍，这时候你只能…😇<h2 id="新的思路-👏🏻"><a href="#新的思路-👏🏻" class="headerlink" title="新的思路:👏🏻"></a>新的思路:👏🏻</h2>我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？</li>
</ul>
<ol>
<li>首先，在store对象中增加getters属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">// 定义一个name，以供全局使用</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wnxx&#x27;</span>,</span><br><span class="line">    <span class="comment">// 定义一个number，以供全局使用</span></span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 定义一个list，以供全局使用</span></span><br><span class="line">    <span class="attr">list</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;welcome&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;to&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;vuex&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// 在store对象中增加getters属性</span></span><br><span class="line">      <span class="attr">getters</span>: &#123;</span><br><span class="line">         <span class="title function_">getMessage</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取修饰后的name，第一个参数state为必要参数，必须写在形参上</span></span><br><span class="line">         <span class="keyword">return</span> <span class="string">`hello<span class="subst">$&#123;state.name&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li>
<li>在组件中使用:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 注意不是$store.state了，而是$store.getters</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">getMessage</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议:"></a>官方建议:</h2>不要每次都写this.$store.getters.XXX，官方建议我们可以使用mapGetters去解构到计算属性中，就像使用mapState一样，就可以直接使用this调用了，就像下面这样：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">getMessage</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;name&#x27;</span>]),</span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;getMessage&#x27;</span>]),</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
当然，和mapState一样你也可以取别名，取外号，就像下面这样：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapGetters</span>(&#123; <span class="attr">aliasName</span>: <span class="string">&#x27;getMessage&#x27;</span> &#125;),  </span><br><span class="line"><span class="comment">// 赋别名的话，这里接收对象，而不是数组</span></span><br></pre></td></tr></table></figure>
🤗 OK，当你看到这里，你已经成功的了解了getters啦！<br>😎 读取值的操作我们有 “原生读（state）” 和 “修饰读（getters）”，接下来就要介绍怎么修改值了！<h1 id="第四步，了解如何修改值：Mutation"><a href="#第四步，了解如何修改值：Mutation" class="headerlink" title="第四步，了解如何修改值：Mutation"></a>第四步，了解如何修改值：Mutation</h1>🤗OK！我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。<h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">XXX</span> = <span class="variable constant_">XXX</span>;</span><br></pre></td></tr></table></figure>
<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因:"></a>错误原因:</h2>因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改。<br>我举个例子：假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作。同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改。<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2>我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来。</li>
<li>修改store/index.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wnxx&#x27;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 增加mutations属性</span></span><br><span class="line">    <span class="title function_">setNumber</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="comment">// 增加一个mutations的方法，方法的作用是让num从0变成10</span></span><br><span class="line">      state.<span class="property">number</span> = <span class="number">10</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li>
<li>修改App.vue<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`旧值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;setNumber&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`新值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？</li>
<li>修改store/index.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setNumber</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">number</span> = <span class="number">10</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setNumberIsWhat</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">      <span class="comment">// 增加一个带参数的mutations方法，并且官方建议payload为一个对象</span></span><br><span class="line">      state.<span class="property">number</span> = payload.<span class="property">number</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li>
<li>修改App.vue<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`旧值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用的时候也需要传递一个对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class="attr">number</span>: <span class="number">666</span> &#125;); </span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`新值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
😱这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！<h2 id="官方建议-1"><a href="#官方建议-1" class="headerlink" title="官方建议:"></a>官方建议:</h2>就像mapState和mapGetters一样，我们在组件中可以使用mapMutations代替this.$store.commit(‘XXX’)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">setNumberIsWhat</span>(&#123; <span class="attr">number</span>: <span class="number">999</span> &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 注意，mapMutations是解构到methods里面的，而不是计算属性了</span></span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;setNumberIsWhat&#x27;</span>]),</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
当然你也可以给它叫别名，取外号，就像这样：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class="line">  ...<span class="title function_">mapMutations</span>(&#123; <span class="attr">setNumberIsAlias</span>: <span class="string">&#x27;setNumberIsWhat&#x27;</span> &#125;), </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
🤪 OK，关于Mutation的介绍大致就是这样。<h1 id="第五步，了解异步操作：Actions"><a href="#第五步，了解异步操作：Actions" class="headerlink" title="第五步，了解异步操作：Actions"></a>第五步，了解异步操作：Actions</h1>上面提到，Mutations只能进行同步操作，Actions存在的意义是假设你在修改state的时候有异步操作，让你放异步操作。<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2></li>
<li>修改store/index.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wnxx&#x27;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setNumberIsWhat</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">      state.<span class="property">number</span> = payload.<span class="property">number</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 增加actions属性</span></span><br><span class="line">    <span class="title function_">setNum</span>(<span class="params">content</span>) &#123;</span><br><span class="line">      <span class="comment">// 增加setNum方法，默认第一个参数是content，其值是复制的一份store</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们模拟一个异步操作，1秒后修改number为666</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          content.<span class="title function_">commit</span>(<span class="string">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class="attr">number</span>: <span class="number">666</span> &#125;);</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>修改App.vue<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`旧值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;setNum&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`新值：<span class="subst">$&#123;<span class="variable language_">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="官方建议1-1"><a href="#官方建议1-1" class="headerlink" title="官方建议1:"></a>官方建议1:</h2>不要一直使用this.$store.dispatch(‘XXX’)这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 就像这样，解构到methods中</span></span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;setNum&#x27;</span>]), </span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 直接这样调用即可</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">setNum</span>(&#123; <span class="attr">number</span>: <span class="number">123</span> &#125;); </span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
当然你也可以给它叫别名，取外号，就像这样：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class="line">  ...<span class="title function_">mapActions</span>(&#123; <span class="attr">setNumAlias</span>: <span class="string">&#x27;setNum&#x27;</span> &#125;),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="官方建议2-1"><a href="#官方建议2-1" class="headerlink" title="官方建议2:"></a>官方建议2:</h2>在store/index.js中的actions里面，方法的形参可以直接将commit解构出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">setNum</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 直接将content解构掉，解构出commit，下面就可以直接调用了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;XXXX&#x27;</span>); <span class="comment">// 直接调用</span></span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
OK，不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。<h1 id="第六步，按属性进行拆分"><a href="#第六步，按属性进行拆分" class="headerlink" title="第六步，按属性进行拆分"></a>第六步，按属性进行拆分</h1>我们看到，一个store/index.js里面大致包含state/getters/mutations/actions这四个属性，我们可以彻底点，index.js里面就保持这个架子，把里面的内容四散到其他文件中。<br>我们可以这样拆分：分别是state.js、 getters.js、 mutations.js 、actions.js</li>
<li>拆出来state放到state.js中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wnxx&#x27;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">list</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;welcome&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;to&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;vuex&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li>
<li>拆出来getters放到getters.js中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getters.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="title function_">getMessage</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello<span class="subst">$&#123;state.name&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>拆出来mutations放到mutations.js中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">setNumber</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">number</span> = <span class="number">10</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>拆出来actions放到actions.js中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="title function_">setNum</span>(<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        content.<span class="title function_">commit</span>(<span class="string">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class="attr">number</span>: <span class="number">888</span> &#125;);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>组装到主文件里面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; state &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span>; <span class="comment">// 引入 state</span></span><br><span class="line"><span class="keyword">import</span> &#123; getters &#125; <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span>; <span class="comment">// 引入 getters</span></span><br><span class="line"><span class="keyword">import</span> &#123; mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations&#x27;</span>; <span class="comment">// 引入 mutations</span></span><br><span class="line"><span class="keyword">import</span> &#123; actions &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>; <span class="comment">// 引入 actions</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123; state, getters, mutations, actions &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<h1 id="第七步，按功能进行拆分-Module"><a href="#第七步，按功能进行拆分-Module" class="headerlink" title="第七步，按功能进行拆分-Module"></a>第七步，按功能进行拆分-Module</h1>上面我们介绍如何拆分项目，采用的是按属性的方式去拆分，接下来，我们介绍一下按另外的一个维度去拆分我们的store，按功能拆分。</li>
<li>我们在之前的store上，增加一个新的仓库store2，主要代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store2.js</span></span><br><span class="line"><span class="keyword">const</span> store2 = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;我是store2&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store2;</span><br></pre></td></tr></table></figure></li>
<li>然后在store中引入我们新创建的store2模块：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; state &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getters &#125; <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; actions &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store2 <span class="keyword">from</span> <span class="string">&#x27;./store2&#x27;</span>; <span class="comment">// 引入store2模块</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// 把store2模块挂载到store里面</span></span><br><span class="line">  <span class="attr">modules</span>: &#123; store2 &#125;, </span><br><span class="line">  <span class="attr">state</span>: state,</span><br><span class="line">  <span class="attr">getters</span>: getters,</span><br><span class="line">  <span class="attr">mutations</span>: mutations,</span><br><span class="line">  <span class="attr">actions</span>: actions,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li>
<li>访问state - 我们在App.vue测试访问store2模块中的state中的name，结果如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 访问store2里面的name属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">store2</span>.<span class="property">name</span>); </span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
我们通过下面的代码可以了解到在不同的属性里是怎么访问模块内的状态或者根状态：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">changeName</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">    <span class="comment">// state 局部状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(payload.<span class="property">where</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="title function_">testGetters</span>(<span class="params">state, getters, rootState</span>) &#123;</span><br><span class="line">    <span class="comment">// state 局部状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">    <span class="comment">// 局部 getters,</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(getters);</span><br><span class="line">    <span class="comment">// rootState 根节点状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rootState);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params">&#123; state, commit, rootState &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// state 局部状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">    <span class="comment">// rootState 根节点状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rootState);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
还有一些关于module的内容，比如命名空间、模块注册全局 action、带命名空间的绑定函数、模块动态注册、模块重用等方法，自己查阅即可。🤗</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的namespaced属性</title>
    <url>/2023/04/05/Vuex%E7%9A%84namespaced%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>举个例子试一下</p>
<h1 id="namespaced为false时"><a href="#namespaced为false时" class="headerlink" title="namespaced为false时"></a>namespaced为false时</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模块test</span><br><span class="line">export default &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: &#x27;zb&#x27;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        ageDouble(state)&#123;</span><br><span class="line">            return (state.age)*2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addAge(state, num)&#123;</span><br><span class="line">            state.age += num </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addAge(context, num)&#123;</span><br><span class="line">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在store/index.js中引入并注册</span><br><span class="line">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class="line">**略**</span><br><span class="line">modules: &#123;</span><br><span class="line">    test        // 注册</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>namespaced属性默认为false，命名空间默认是关闭的，即模块内部的 action、mutation 和 getter 是注册在全局命名空间的。</p>
<h2 id="使用模块test的state数据"><a href="#使用模块test的state数据" class="headerlink" title="使用模块test的state数据"></a>使用模块test的state数据</h2><p>this.$store.state.test.age</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      testName: state=&gt;state.test.name,</span><br><span class="line">      testAge: state=&gt;state.test.age</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">this.testName</span><br><span class="line">this.testAge</span><br></pre></td></tr></table></figure>
<h2 id="使用模块test的getters，mutation，action"><a href="#使用模块test的getters，mutation，action" class="headerlink" title="使用模块test的getters，mutation，action"></a>使用模块test的getters，mutation，action</h2><p>调用模块test的getters，mutations，actions和store/index.js下的计算属性和方法没有区别，因为都在全局命名空间</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>this.$store.getters.ageDouble</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class="line">computed: &#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      testAgeDouble: &#x27;ageDouble&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapGetters([&#x27;ageDouble&#x27;])</span><br><span class="line">  &#125;, </span><br><span class="line">this.testAgeDouble</span><br><span class="line">this.ageDouble</span><br></pre></td></tr></table></figure>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>this.$store.commit(‘addAge’, 2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class="line">methods:&#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      testAddAge: &#x27;addAge&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapMutations([&#x27;addAge&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">this.testAddAge(2)</span><br><span class="line">this.addAge(2)</span><br></pre></td></tr></table></figure>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>this.$store.dispatch(‘addAge’, 2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class="line">methods:&#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      testAddAge: &#x27;addAge&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapActions([&#x27;addAge&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">this.testAddAge(2)</span><br><span class="line">this.addAge(2)</span><br></pre></td></tr></table></figure>
<h1 id="namespaced为true时"><a href="#namespaced为true时" class="headerlink" title="namespaced为true时"></a>namespaced为true时</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: &#x27;zb&#x27;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        ageDouble(state)&#123;</span><br><span class="line">            return (state.age)*2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addAge(state, num)&#123;</span><br><span class="line">            state.age += num </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addAge(context, num)&#123;</span><br><span class="line">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在store/index.js中引入并注册</span><br><span class="line">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class="line">**略**</span><br><span class="line">modules: &#123;</span><br><span class="line">    test        // 注册</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>namespaced属性设为true时，说明模块test拥有自己的命名空间，可以防止与其他模块的计算属性和方法混杂，看起来也更清晰。</p>
<h2 id="使用模块test的state数据-1"><a href="#使用模块test的state数据-1" class="headerlink" title="使用模块test的state数据"></a>使用模块test的state数据</h2><p>同命名空间为false没有区别<br>this.$store.state.test.age</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      testName: state=&gt;state.test.name,</span><br><span class="line">      testAge: state=&gt;state.test.age</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">this.testName</span><br><span class="line">this.testAge</span><br></pre></td></tr></table></figure>
<h2 id="使用模块test的getters，mutation，action-1"><a href="#使用模块test的getters，mutation，action-1" class="headerlink" title="使用模块test的getters，mutation，action"></a>使用模块test的getters，mutation，action</h2><h3 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h3><p>this.$store.getters[‘test/ageDouble’]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class="line">computed: &#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      testAgeDouble: &#x27;test/ageDouble&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapGetters(&#x27;test&#x27;, [&#x27;ageDouble&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">this.testAgeDouble</span><br><span class="line">this.ageDouble</span><br></pre></td></tr></table></figure>
<h3 id="mutations-1"><a href="#mutations-1" class="headerlink" title="mutations"></a>mutations</h3><p>this.$store.commit(‘test/addAge’, 2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class="line">methods:&#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapMutations(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">this.testAddAge(2)</span><br><span class="line">this.addAge(2)</span><br></pre></td></tr></table></figure>
<h3 id="actions-1"><a href="#actions-1" class="headerlink" title="actions"></a>actions</h3><p>this.$store.dispatch(‘test/addAge’, 2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class="line">methods:&#123;</span><br><span class="line">    // 起别名</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 不起别名</span><br><span class="line">    ...mapActions(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">this.testAddAge(2)</span><br><span class="line">this.addAge(2)</span><br></pre></td></tr></table></figure>
<p>当命名空间开启之后，再使用模块test的计算属性和方法就要添加一个模块名的前缀。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue更新机制</title>
    <url>/2023/09/21/Vue%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Vue-模板编译机制"><a href="#Vue-模板编译机制" class="headerlink" title="Vue 模板编译机制"></a>Vue 模板编译机制</h1><p>在 Vue 中，模板编译是将 Vue 模板转换为渲染函数的过程。Vue 模板是一种 HTML 扩展语言，支持添加一些特殊的指令和表达式。例如，可以使用 v-bind 指令绑定 HTML 属性，使用 v-on 指令添加事件处理程序，使用<code>&#123;&#123; &#125;&#125;</code>表达式插入动态数据等。</p>
<h2 id="Vue-的模板编译过程可以分为三个阶段"><a href="#Vue-的模板编译过程可以分为三个阶段" class="headerlink" title="Vue 的模板编译过程可以分为三个阶段"></a>Vue 的模板编译过程可以分为三个阶段</h2><ul>
<li>解析阶段<br>将模板解析为抽象语法树(AST)。在这个阶段中，Vue 会解析模板中的所有指令和表达式，并生成对应的 AST 节点。</li>
<li>优化阶段<br>对 AST 进行优化。在这个阶段中，Vue 会对 AST 进行静态分析和优化，减少不必要的计算，生成优化后的 AST。</li>
<li>代码生成阶段<br>将 AST 转换为渲染函数。在这个阶段中，Vue 会将生成的 AST 转换为可执行的 JavaScript 代码，并返回渲染函数。</li>
</ul>
<h1 id="Vue-更新"><a href="#Vue-更新" class="headerlink" title="Vue 更新"></a>Vue 更新</h1><p>Vue 使用响应式系统来<code>收集依赖</code>和<code>派发更新</code>，当模板中数据发生变化时，组件的 render 函数会被作为数据的依赖而被触发，只不过这个触发并不是立刻的，因为模板中会引用很多数据，render 同时是这些所有数据的依赖项，如果 render 每次都立刻执行，则会造成多次重复渲染而消耗性能。</p>
<p>实际上 render 是被 update 调用的，而 update 又是 Watcher 调用的，而 Watcher 在收到 Dep 的派发更新时会把自身交给 Scheduler ，由 Scheduler 负责对其去重并通过 nextTick() 将这些 Watcher 包装成微任务放入到事件循环中等待调用。</p>
<p>render 执行输出的结果是一颗新的虚拟 DOM 树，然后 update 会通过 patch 函数将它与旧的虚拟 DOM 树进行对比，diff 和真实 DOM 的操作过程既是在 patch 函数中进行。</p>
<p>所以，其实 Vue 的整个更新任务（构建虚拟 DOM ，diff，操作真实 DOM）可以算作一个整体，这个整体被当作微任务来处理，这也就是 Vue 异步更新的原理。</p>
<h1 id="Vue-渲染机制"><a href="#Vue-渲染机制" class="headerlink" title="Vue 渲染机制"></a>Vue 渲染机制</h1><p>在 Vue 中，渲染是将 Vue 实例的状态转换为 DOM 的过程。当 Vue 实例的状态变化时，会触发重新渲染，自动更新视图。</p>
<p>虚拟 DOM (Virtual DOM，简称 VDOM) 是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。</p>
<p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为挂载 (mount)。<br>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为更新 (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。</p>
<h2 id="Vue-组件挂载时会发生"><a href="#Vue-组件挂载时会发生" class="headerlink" title="Vue 组件挂载时会发生"></a>Vue 组件挂载时会发生</h2><ul>
<li><p>编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</p>
</li>
<li><p>挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。</p>
</li>
<li><p>更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</p>
</li>
</ul>
<h2 id="Vue-的渲染过程可以分为以下几个步骤"><a href="#Vue-的渲染过程可以分为以下几个步骤" class="headerlink" title="Vue 的渲染过程可以分为以下几个步骤"></a>Vue 的渲染过程可以分为以下几个步骤</h2><ul>
<li>创建虚拟 DOM<br>Vue 会通过渲染函数获取虚拟 DOM，用于描述界面结构。</li>
<li>更新虚拟 DOM<br>当视图需要更新时，Vue 会通过 diff 算法比较新旧虚拟 DOM 的差异，生成可以最小化更新的操作序列。</li>
<li>应用更新<br>最后，Vue 会根据生成的操作序列，将变化应用到实际的 DOM 上。</li>
</ul>
<h2 id="Vue-官方文档图"><a href="#Vue-官方文档图" class="headerlink" title="Vue 官方文档图"></a>Vue 官方文档图</h2><p><img src="/2023/09/21/Vue%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="为什么-Vue-默认推荐使用模板，不是渲染函数呢？"><a href="#为什么-Vue-默认推荐使用模板，不是渲染函数呢？" class="headerlink" title="为什么 Vue 默认推荐使用模板，不是渲染函数呢？"></a>为什么 Vue 默认推荐使用模板，不是渲染函数呢？</h1><p>Vue 模板会被预编译成虚拟 DOM 渲染函数。Vue 也提供了 API 使我们可以不使用模板编译，直接手写渲染函数。在处理高度动态的逻辑时，渲染函数相比于模板更加灵活，因为你可以完全地使用 JavaScript 来构造你想要的 vnode。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li><p>模板更贴近实际的 HTML。这使得我们能够更方便地重用一些已有的 HTML 代码片段，能够带来更好的可访问性体验、能更方便地使用 CSS 应用样式，并且更容易使设计师理解和修改。</p>
</li>
<li><p>由于其确定的语法，更容易对模板做静态分析。这使得 Vue 的模板编译器能够应用许多编译时优化来提升虚拟 DOM 的性能表现。</p>
</li>
</ul>
<p>在实践中，模板对大多数的应用场景都是够用且高效的。渲染函数一般只会在需要处理高度动态渲染逻辑的可重用组件中使用。</p>
<h1 id="Vue-与-React-更新机制区别"><a href="#Vue-与-React-更新机制区别" class="headerlink" title="Vue 与 React 更新机制区别"></a>Vue 与 React 更新机制区别</h1><ul>
<li>触发更新机制</li>
</ul>
<ol>
<li>Vue 是通过响应式系统自动及时的进行触发</li>
<li>React 则是通过用户更改状态的操作然后进行一系列调度来触发更新</li>
</ol>
<ul>
<li>任务的区别</li>
</ul>
<ol>
<li>Vue 会将任务包装成微任务</li>
<li>React 则是将其包装成宏任务</li>
</ol>
<p>虽然都是异步任务，但它们有很大区别。在事件循环中，如果有微任务存在则会先一直执行微任务，直到把微任务队列清空，然后再执行宏任务，并且在每个宏任务执行完毕后，会立即检查并执行所有微任务，然后再进行下一个宏任务的执行。</p>
<p>先明确一点：异步任务执行时是由主线程进行执行的，所以此时它们已经相当于是同步执行了（这个异步实际指的是异步任务在任务队列里面等待的时候不会影响主线程的执行）</p>
<p>微任务执行时不会穿插其它任务（比如浏览器渲染），所以当有大量微任务堆积时可能就会阻塞浏览器渲染（异步任务），但执行完一个宏任务时如果遇到浏览器需要渲染，则不会继续执行下一个宏任务而是转去进行浏览器渲染然后开启新的一轮事件循环。</p>
<p>因为 React 的 Fiber 架构的出现就是为了能够随时打断，把控制权交给主线程，所以 React 采用的是宏任务，而不是会一股脑 “ 全冲完 ” 的微任务，这样可以避免微任务过多而导致的任务堆积和性能问题。<br>也正是因为 Vue 的理念是追求响应性和即时效果并避免过多的渲染，所以它采用微任务，及时把更新任务处理完，最后让浏览器渲染一次即可。<br>其实现如今，React 和 Vue 都不是完全使用某一种任务，在一些情况下 React 也会使用微任务，Vue 也是如此，它们的目标都是想要结合自身情况来创造一个更优秀的框架。</p>
<ul>
<li>diff 算法的不同</li>
</ul>
<ol>
<li>Vue 采用双端对比</li>
<li>React 使用的是 Reconciliation 算法。</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目遇到问题</title>
    <url>/2023/04/12/Vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>列表进入详情页的传参问题。<br>例如商品列表页面前往商品详情页面，需要传一个商品id;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;path: &#x27;detail&#x27;, query: &#123;id: 1&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>前往detail页面</router-link>c页面的路径为<a href="http://localhost:8080/#/detail?id=1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BC%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0id=1%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%B1%E7%AE%97%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2id%E4%B9%9F%E8%BF%98%E4%BC%9A%E5%AD%98%E5%9C%A8%E3%80%82%E6%AD%A4%E6%97%B6%E5%9C%A8c%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87id%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AF%A6%E6%83%85%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%8E%B7%E5%8F%96id%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AFthis.$route.query.idvue%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9Aquery%E3%80%81params+%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E3%80%82">http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.idvue传参方式有：query、params+动态路由传参。</a><br>说下两者的区别：   <br>1.query通过path切换路由，params通过name切换路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// query通过path切换路由</span><br><span class="line">&lt;router-link :to=&quot;&#123;path: &#x27;Detail&#x27;, query: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class="line">// params通过name切换路由</span><br><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt; </span><br></pre></td></tr></table></figure>
<p>2.query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// query通过this.$route.query接收参数</span><br><span class="line">created () &#123;</span><br><span class="line">    const id = this.$route.query.id;</span><br><span class="line">&#125;</span><br><span class="line">// params通过this.$route.params来接收参数</span><br><span class="line">created () &#123;</span><br><span class="line">    const id = this.$route.params.id;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>3.query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数       params＋动态路由的url方式：/detail/123   <br>4.params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;      </span><br><span class="line">    path: &#x27;/detail/:id&#x27;,      </span><br><span class="line">    name: &#x27;Detail&#x27;,      </span><br><span class="line">    component: Detail    </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义的路由中，只定义一个id参数</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;detail/:id&#x27;,</span><br><span class="line">    name: &#x27;Detail&#x27;,</span><br><span class="line">    components: Detail</span><br><span class="line">&#125;</span><br><span class="line">// template中的路由传参，</span><br><span class="line">// 传了一个id参数和一个token参数</span><br><span class="line">// id是在路由中已经定义的参数，而token没有定义</span><br><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1, token: &#x27;123456&#x27; &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class="line">// 在详情页接收</span><br><span class="line">created () &#123;</span><br><span class="line">    // 以下都可以正常获取到</span><br><span class="line">    // 但是页面刷新后，id依然可以获取，而token此时就不存在了</span><br><span class="line">    const id = this.$route.params.id;</span><br><span class="line">    const token = this.$route.params.token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>classNames库</title>
    <url>/2023/12/18/classNames%E5%BA%93/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>classNames 是一个 JavaScript 库,用于动态生成 CSS 类名，根据不同的条件添加或移除 CSS 类名。简单来说就是动态地去操作类名，把符合条件的类名粘在一起，简化在 React 组件中处理类名的复杂逻辑。</p>
<h1 id="安装（使用-npm）"><a href="#安装（使用-npm）" class="headerlink" title="安装（使用 npm）"></a>安装（使用 npm）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install classnames</span><br></pre></td></tr></table></figure>

<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="在-nodejs-里引入"><a href="#在-nodejs-里引入" class="headerlink" title="在 nodejs 里引入"></a>在 nodejs 里引入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var classNames = require(&#x27;classnames&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="在-js-里引入"><a href="#在-js-里引入" class="headerlink" title="在 js 里引入"></a>在 js 里引入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import classnames from &#x27;classnames&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>classNames 函数接受任意数量的参数，可以是 string、boolean、number、array 等。</p>
<h2 id="普通字符串粘合"><a href="#普通字符串粘合" class="headerlink" title="普通字符串粘合"></a>普通字符串粘合</h2><p>将参数拼接为字符串，中间用空格分开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classNames(&#x27;foo&#x27;, &#x27;bar&#x27;) // =&gt; &#x27;foo bar&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="带条件的类参数"><a href="#带条件的类参数" class="headerlink" title="带条件的类参数"></a>带条件的类参数</h2><p>这里第二个参数是对象类型，键值为 true，则粘合进 className 里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classNames(&#x27;foo&#x27;, &#123; bar: true &#125;) // =&gt; &#x27;foo bar&#x27;</span><br></pre></td></tr></table></figure>

<p>若为 false，则不粘进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classNames(&#x27;foo&#x27;, &#123; bar: false &#125;) // =&gt; &#x27;foo&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="参数类型是数组"><a href="#参数类型是数组" class="headerlink" title="参数类型是数组"></a>参数类型是数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;b&#x27;, &#123; c: true, d: false &#125;]</span><br><span class="line">classNames(&#x27;a&#x27;, arr) // =&gt; &#x27;a b c&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><p>null 和 undefiend 会被忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classNames(null, false, &#x27;bar&#x27;, undefined, 0, 1, &#123; baz: null &#125;, &#x27;&#x27;) // =&gt; &#x27;bar 1&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="在-React-中优雅地使用-classnames"><a href="#在-React-中优雅地使用-classnames" class="headerlink" title="在 React 中优雅地使用 classnames"></a>在 React 中优雅地使用 classnames</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import classnames from &#x27;classnames&#x27;</span><br><span class="line"></span><br><span class="line">const Button = (&#123;primary,size&#125;)=&gt;&#123;</span><br><span class="line">  const classes = classnames(&#x27;btn&#x27;, &#123;</span><br><span class="line">    &#x27;btn-primary&#x27;:primary,</span><br><span class="line">    &#x27;btn-large&#x27;: size===&#x27;large&#x27;,</span><br><span class="line">    &#x27;btn-small&#x27;: size===&#x27;small&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  return &lt;button className= &#123;classes&#125;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，classnames 函数接受一个类名和一个将类名映射为布尔值的对象。<br>classes 就可以变成一个对象，通过键值的条件确定最终生成的 className。</p>
<ul>
<li>如果给定类名的布尔值为 true，则该类名将包含在类名的最终列表中。</li>
<li>如果给定类名的布尔值为 false，则不包括类名。<br>另外可以将字符串作为第二个参数传递给类名，如果给定类名的布尔值为 true，那么它将被添加到类名的最终列表中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const classes = classnames(&#x27;btn&#x27;, primary &amp;&amp; &#x27;btn-primary&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="classNames-源码"><a href="#classNames-源码" class="headerlink" title="classNames 源码"></a>classNames 源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">	&#x27;use strict&#x27;</span><br><span class="line">  //hasOwnProperty这个方法用来判断对象的属性是否属于自己本身——而不是往原型链上面找到的</span><br><span class="line">	var hasOwn = &#123;&#125;.hasOwnProperty</span><br><span class="line"></span><br><span class="line">	function classNames () &#123;</span><br><span class="line">    //用于存储生成的类名</span><br><span class="line">		var classes = &#x27;&#x27;</span><br><span class="line">    //遍历classnames的所有参数</span><br><span class="line">		for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      //遍历 arguments 拿到每一项</span><br><span class="line">			var arg = arguments[i]</span><br><span class="line">			if (arg) &#123;</span><br><span class="line">				classes = appendClass(classes, parseValue(arg))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return classes</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function parseValue (arg) &#123;</span><br><span class="line">    //获取每一个参数的类型</span><br><span class="line">    //如果是字符串或数字就直接加到classes数组里</span><br><span class="line">		if (typeof arg === &#x27;string&#x27; || typeof arg === &#x27;number&#x27;) &#123;</span><br><span class="line">			return arg</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (typeof arg !== &#x27;object&#x27;) &#123;</span><br><span class="line">			return &#x27;&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">    //如果参数是数组，则将数组的值当作参数，调用自己</span><br><span class="line">		if (Array.isArray(arg)) &#123;</span><br><span class="line">			return classNames.apply(null, arg)</span><br><span class="line">		&#125;</span><br><span class="line">    //如果是对象且有自定义的toString方法，则调用toString方法添加到classes对象里</span><br><span class="line">		if (arg.toString !== Object.prototype.toString &amp;&amp; !arg.toString.toString().includes(&#x27;[native code]&#x27;)) &#123;</span><br><span class="line">			return arg.toString()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var classes = &#x27;&#x27;</span><br><span class="line">    //对于普通对象类型，则遍历对象的每一组键值对</span><br><span class="line">		for (var key in arg) &#123;</span><br><span class="line">      //将值为true的键作为className插入classes数组里</span><br><span class="line">			if (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123;</span><br><span class="line">				classes = appendClass(classes, key)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return classes</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function appendClass (value, newClass) &#123;</span><br><span class="line">		if (!newClass) &#123;</span><br><span class="line">			return value</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (value) &#123;</span><br><span class="line">			return value + &#x27; &#x27; + newClass</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return value + newClass</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) &#123;</span><br><span class="line">		classNames.default = classNames</span><br><span class="line">		module.exports = classNames</span><br><span class="line">	&#125; else if (typeof define === &#x27;function&#x27; &amp;&amp; typeof define.amd === &#x27;object&#x27; &amp;&amp; define.amd) &#123;</span><br><span class="line">		// register as &#x27;classnames&#x27;, consistent with npm package name</span><br><span class="line">		define(&#x27;classnames&#x27;, [], function () &#123;</span><br><span class="line">			return classNames</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		window.classNames = classNames</span><br><span class="line">	&#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先分析 index.js，采用了自执行的函数，避免变量污染冲突，采用严格模式。</p>
<ol>
<li>函数声明了一个名为 classes 的空数组，该数组将用于存储生成的类名。</li>
<li>然后，for 循环函数自带 arguments 实例，得到 classnames 函数的所有实参。<br>对于每个参数，执行以下步骤:</li>
</ol>
<ul>
<li>检查参数的类型。<ul>
<li>如果参数是一个字符串或数字，添加到类数组。</li>
<li>如果参数是数组，则函数检查它是否为非空。如果是，则函数以数组元素作为参数递归地调用自身，并将结果添加到类数组中。</li>
<li>如果参数是一个对象，那么先判定它的 toString 方法是否重写了。<ul>
<li>如果是重写了，直接将调用 toString 的结果添加到类数组中。</li>
<li>如果不是，函数将遍历对象自己的可枚举属性，并将属性名称添加到类数组中(如果它们的对应值为真)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>提供了三种导出 classNames 的方式。</li>
</ol>
<ul>
<li>module.exports 导出 classNames</li>
<li>直接返回 classNames</li>
<li>将 classNames 挂载到 window 上</li>
</ul>
<ol start="4">
<li>循环结束后，将类数组合并到一个单独的字符串中，并返回结果字符串。</li>
</ol>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li>arg.toString !== Object.prototype.toString 是什么？</li>
</ol>
<p>首先所有 js 对象都继承 Object 对象，都继承 toString 方法，这个表达式就是这个对象的 toString 方法不是继承自 Object.prototype</p>
<ol start="2">
<li>arg.toString.toString().includes(“[native code]”) 是什么意思？</li>
</ol>
<p>首先要知道 toString 方法的一些知识：</p>
<ul>
<li>如果对一个自定义函数调用 toString()方法时，可以得到该函数的源代码。</li>
<li>如果对内置函数调用 toString()方法时，会得到一个’[native code]’字符串。<br>因此，可以使用 toString()方法来区分自定义函数和内置函数。<br>注意：上诉表达式中是对函数调用 toString()方法。<br>通过对 toString 函数调用 toString 方法，就可以判断这个 toString 是内置的，还是自定义的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg.toString !== Object.prototype.toString &amp;&amp; !arg.toString.toString().includes(&#x27;[native code])</span><br></pre></td></tr></table></figure>

<p>这里两个表达式连起来的意思就是：现在这个类有 toString 方法，而且还是自定义的</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>从源码来看，classNames 能够接入的参数是多种多样的，下面列举一些。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字符串(能够单个，多个字符串)</span><br><span class="line">classNames(&#x27;el-checkbox-button--m&#x27;, &quot;is-disabled&quot;)</span><br><span class="line"></span><br><span class="line">//对象(能够单个，多个)</span><br><span class="line">classNames(&#123;&quot;is-disabled&quot;：true&#125;, &#123;&#x27;is-disabled&#x27;: disabled&#125;)</span><br><span class="line"></span><br><span class="line">//字符串+对象</span><br><span class="line">classNames(&#x27;el-checkbox-button--m&#x27;, &#123;&quot;is-disabled&quot;：true, &#x27;is-disabled&#x27;: disabled&#125;)</span><br><span class="line"></span><br><span class="line">//数组（数组项能够是字符串，对象）</span><br><span class="line">classNames([&#x27;el-checkbox-button--m&#x27;, &quot;is-disabled&quot;])</span><br><span class="line">classNames([&#x27;el-checkbox-button--m&#x27;, &#123;&quot;is-disabled&quot;：true，&#x27;is-disabled&#x27;: disabled&#125;])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>classNames库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目SEO优化-Nuxt</title>
    <url>/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/</url>
    <content><![CDATA[<h1 id="为什么SPA需要SEO"><a href="#为什么SPA需要SEO" class="headerlink" title="为什么SPA需要SEO"></a>为什么SPA需要SEO</h1><p>通常我们用前端框架（这里以Vue为例）产出的代码一般是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面实际展示的内容（用户实际看到的内容）都是通过js渲染出来的，所以搜索引擎爬虫在对我们的页面进行爬取的时候，拿到的也是上面的html代码。虽然我们可以通过在<head></head>中添加<meta/>标签来添加一些描述信息，但是远远不够，我们实际展示的内容搜索引擎爬虫还是拿不到，所以就需要对项目进行SEO优化。</p>
<h1 id="关于Nuxt-js"><a href="#关于Nuxt-js" class="headerlink" title="关于Nuxt.js"></a>关于Nuxt.js</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目Nuxt.js这让一切变得非常简单。Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。</p>
<h2 id="简单的理解："><a href="#简单的理解：" class="headerlink" title="简单的理解："></a>简单的理解：</h2><p>代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。</p>
<h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>纯静态文件，访问速度快</li>
<li>对比SSR,不涉及服务器负载方面问题</li>
<li>静态网页不宜遭到黑客工具，安全性高<h2 id="服务端渲染和客户端渲染"><a href="#服务端渲染和客户端渲染" class="headerlink" title="服务端渲染和客户端渲染"></a>服务端渲染和客户端渲染</h2></li>
</ul>
<ol>
<li>浏览器（客户端）通过AJAX向服务端（java servlet）发送http请求数据接口</li>
<li>服务端将获取的接口数据封装成JSON，响应给浏览器</li>
<li>浏览器拿到JSON就进行渲染html页面，生成DOM元素，然后将页面展示给用户<br><img src="/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><h2 id="Nuxt-js工作原理"><a href="#Nuxt-js工作原理" class="headerlink" title="Nuxt.js工作原理"></a>Nuxt.js工作原理</h2></li>
<li>浏览器(客户端)发送http请求到Node.js服务端。</li>
<li>部署在Node.js的应用Nuxt.js接收到浏览器请求，它会去请求后台服务端。</li>
<li>后台接口服务端会响应JSON数据，Nuxt.js获取数据后进行服务端渲染成html。</li>
<li>然后Nuxt.js将html页面响应给浏览器</li>
<li>浏览器直接将接收到html页面进行展示<br><img src="/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/nuxt%E6%B8%B2%E6%9F%93.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。"><a href="#首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。" class="headerlink" title="首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。"></a>首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。</h3><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.nuxt</span><br><span class="line">1. assets //资源目录 组织为编译的静态资源 大家都懂</span><br><span class="line">      image.png</span><br><span class="line">2.components // 组织 Vue.js 组件，NUXT不会扩展增强该目录下的组件，这意味着组件不能使用 </span><br><span class="line">3.asyncData 方法</span><br><span class="line">4.layout // 布局目录 如果没有额外配置，目录不能重命名--不建议改名</span><br><span class="line">5.middleware // 用于存放应用的中间件</span><br><span class="line">6.node_modules </span><br><span class="line">7.pages // 页面目录用于组织应用路由及视图，NUXT会读取该目录下所有.vue文件并自动生成路由（路由文件在 .nuxt/router.js）</span><br><span class="line">      index.vue</span><br><span class="line">8.plugins // 插件目录 用于组织那些需要在跟vue.js应用，实例化之前需要运行的Javascript插件</span><br><span class="line">9.static // 用于存放应用的静态文件，此类文件不会被NUXT.js调用Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径  `/`  下。例如 /static/root.txt 映射至 /root.txt</span><br><span class="line">10.store // Nuxt.js 框架集成了 [Vuex 状态树] 的相关功能配置，在  `store`  目录下创建一个  `index.js`  文件可激活这些配置。 新建一个index.js 这事就算妥了</span><br><span class="line">11.nuxt.config.js // 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置 不要gai&#x27;ming&#x27;zi</span><br><span class="line">12.package.json // 用于描述应用的依赖关系和对外暴露的脚本接口</span><br></pre></td></tr></table></figure>
<h3 id="NUXT开发中需要注意哪些。"><a href="#NUXT开发中需要注意哪些。" class="headerlink" title="NUXT开发中需要注意哪些。"></a>NUXT开发中需要注意哪些。</h3><h4 id="静态资源的引入和路由"><a href="#静态资源的引入和路由" class="headerlink" title="静态资源的引入和路由"></a>静态资源的引入和路由</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入静态资源 和 跳转路由</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!--我们不需要去配置 @去指向根目录  NUXT中可以直接使用 --&gt;</span><br><span class="line">  &lt;img src=&quot;~/assets/image.png&quot; /&gt;</span><br><span class="line">  &lt;!--NUXT中我们不需要去写路由表  👇 &#x27;/&#x27;指的是 page/index.vue 其它语法和日常无恙  --&gt;</span><br><span class="line">  &lt;nuxt-link :to=&quot;&#123;name:&#x27;userPage&#x27;,query:&#123;id:&#x27;111&#x27;&#125;&#125;&quot;&gt;个人中心&lt;/nuxt-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h4>Nuxt.js扩展了Vue.js 增加了asyncData的方法，这样我们可以在渲染组件之前异步获取数据，asyncData方法会在组件（只限于页面组件）每次加载之前被调用，它可以在服务端或路由更新之前被调用，在这个方法被调用的时候，第一个参数context被设定为当前页的上下文对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async asyncData(&#123; params &#125;)&#123;  // params 就是传进来的值</span><br><span class="line">//asyncData 函数去执行我们的异步操作 当我们获取到接口返回的内容是 此时我们Vue还没有实例化 所以this获取不到  我们通过返回 方法 去获取  因此标签内如果需要展示内容  &#123;&#123;info.XXX&#125;&#125;</span><br><span class="line">	const data = await $axios.$get(&#x27;/api/user&#x27;)</span><br><span class="line">	return &#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nuxtjs-axios"><a href="#nuxtjs-axios" class="headerlink" title="@nuxtjs/axios"></a>@nuxtjs/axios</h4>我们在asyncData中调用接口，在Nuxt.js官方提供了@nuxtjs/axios模块，此模块还包含了axios、@nuxtjs/proxy（解决异步,进行代理转发）模块。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.安装@nuxtjs/axios：</span><br><span class="line">npm install @nuxtjs/axios</span><br><span class="line">// 2.在nuxt.config.js中配置axios</span><br><span class="line">module.exports=&#123;</span><br><span class="line">	modules:[&#x27;@nuxtjs/axios&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4>中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。可用于权限判断，有权限才可访问对应页面<br>中间件应放置在middleware/ 目录。文件名的名称将成为中间件名称（middleware/auth.js将成为auth中间件）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建权限中间件</span><br><span class="line">//在 middleware/ 下创建 auth.js 文件，其中auth就是中间件的名称。</span><br><span class="line">//一个中间件接收content作为第一个参数</span><br><span class="line">export default(&#123; store, redirect &#125;) =&gt; &#123;</span><br><span class="line">	if(/* 没有token */)&#123;</span><br><span class="line">		return redirect(&#x27;/&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Nuxt对Vue项目首页进行SEO优化"><a href="#Nuxt对Vue项目首页进行SEO优化" class="headerlink" title="Nuxt对Vue项目首页进行SEO优化"></a>Nuxt对Vue项目首页进行SEO优化</h1>Nuxt.js 集成了以下组件/框架，用于开发完整而强大的Web 应用：</li>
</ol>
<ul>
<li>Vue 2</li>
<li>Vue-Router</li>
<li>Vuex(当配置了Vuex状态树配置项时才会引入)</li>
<li>Vue服务器端渲染 (排除使用mode:’spa’)</li>
<li>Vue-Meta<br>另外，Nuxt.js使用Webpack和vue-loader 、babel-loader来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3>因为是对项目的一部分进行改造，所以新建了一个项目。<br>新创建的项目目录大致如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ assets:静态资源</span><br><span class="line">+ components:组件，该文件夹下的组件使用时无需引入，类似于已经全局注册了，这些组件无法使用asyncData。</span><br><span class="line">+ layouts:用于组织应用的布局组件，我理解类似于Vue项目中的App.vue</span><br><span class="line">+ middlwware:应用的中间件，这个没有用到</span><br><span class="line">+ node_modules:依赖包</span><br><span class="line">+ pages:页面，Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。在这个目录里使用其他类型的文件在npm run generate时可能会报错</span><br><span class="line">+ plugins:插件目录。用于组织需要再根Vue.js应用实例化之前需要运行的JavaScript插件。在任何 Vue 组件的生命周期内，只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。</span><br><span class="line">+ static:静态文件目录。</span><br><span class="line">静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。</span><br><span class="line">store</span><br><span class="line">+ Vuex状态树。</span><br><span class="line">Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。</span><br><span class="line">+ nuxt.config.js</span><br><span class="line">nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class="line">+ 其他</span><br><span class="line">.babelrc、.editorconfig、package.json、package-lock.json等，和其他项目中同名文件功能相同。</span><br><span class="line">+ 别名</span><br><span class="line">~或@ =&gt; srcDir</span><br><span class="line">~~或@@ =&gt; rootDir</span><br></pre></td></tr></table></figure>
在vue模板中, 如果需要引入assets或者static目录, 使用<del>/assets/your_image.png和</del>/static/your_image.png方式。<h3 id="迁移文件"><a href="#迁移文件" class="headerlink" title="迁移文件"></a>迁移文件</h3>把老项目首页及宣传页的代码以及依赖的静态文件，还有一些eslint的配置，webpack配置等，能用的都拿过来，然后修改引用路径，删除不需要的代码。<br>下面是目录的对应关系：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ assets:css、icon、font等静态资源</span><br><span class="line">+ components:首页及宣传页用到的组件</span><br><span class="line">+ layouts:App.vue</span><br><span class="line">+ middlwware</span><br><span class="line">+ node_modules:依赖包</span><br><span class="line">+ pages:首页及宣传页涉及到的页面。</span><br><span class="line">+ plugins:用到的各种插件。</span><br><span class="line">      + axios封装（没有用Nuxt.js默认的@nuxtjs/axios）</span><br><span class="line">      + elementUI</span><br><span class="line">      + 其他一些用到的插件（video、zepto等）</span><br><span class="line">      + 工具函数（这里有疑问，是不是应该放在assets下面）</span><br><span class="line">+ static:.ico文件</span><br><span class="line">+ store:vuex相关文件</span><br><span class="line">+ nuxt.config.js:nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class="line">+ 其他:.babelrc、.editorconfig、package.json、package-lock.json等，和其他功能相同。</span><br></pre></td></tr></table></figure>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3>这部分是重点，因为Nuxt很多东西其实在一开始就都配置好了，比如像它的目录结构，官方都建议一般不要修改。如果想修改配置的话，必须在nuxt.config.js中进行修改。Nuxt关于配置的文档很多，这里直说我用到的部分。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">&#x27;webpack&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">ssr</span>: <span class="literal">false</span>, <span class="comment">// 是否启用服务端渲染。默认为false，创建时可选择</span></span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;static&#x27;</span>, <span class="comment">// server：用于服务器端渲染，static：用于静态网站</span></span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;/page/&#x27;</span> <span class="comment">// 应用程序的基本URL，如果在此路径下提供了整个应用程序，则应该使用root.base。使用之后，访问***.com/home路由应该使用***.com/page/home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">head</span>: &#123; <span class="comment">// 一些静态资源的引入，填写头信息</span></span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;nuxt-demo&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: [</span><br><span class="line">      &#123; <span class="attr">charset</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;viewport&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">hid</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">script</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">src</span>: <span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/zepto/1.2.0/zepto.js&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">css</span>: [ <span class="comment">// 全局使用的css</span></span><br><span class="line">    <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;~/assets/css/common.css&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;~/assets/css/element-variables.scss&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="comment">//  使用插件</span></span><br><span class="line">    &#123;<span class="attr">src</span>: <span class="string">&#x27;~plugins/element-ui&#x27;</span>&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">src</span>: <span class="string">&#x27;~plugins/log.js&#x27;</span>,</span><br><span class="line">      <span class="attr">mode</span>: <span class="string">&#x27;client&#x27;</span> <span class="comment">// client或server：文件仅包含在客户端或服务器端，如果代码中使用了window或document等浏览器端才有的API，只能使用client</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">src</span>: <span class="string">&#x27;~plugins/route.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="attr">mode</span>: <span class="string">&#x27;client&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">components</span>: <span class="literal">true</span>, <span class="comment">// 自动引入组件</span></span><br><span class="line">  <span class="attr">buildModules</span>: [ <span class="comment">// 某些模块仅在开发和构建期间需要。使用buildModules有助于加快生产启动速度，并大大减少node_modules生产部署的规模。</span></span><br><span class="line">    <span class="string">&#x27;@nuxtjs/eslint-module&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">build</span>: &#123; <span class="comment">// Nuxt.js 允许你根据服务端需求，自定义 webpack 的构建配置。</span></span><br><span class="line">    <span class="attr">transpile</span>: [<span class="regexp">/^element-ui/</span>], <span class="comment">// 使用Babel与特定的依赖关系进行转换。应该是element-ui使用了ES6语法，所以需要进行转化</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 静态资源引用路径（通常使用CND地址）</span></span><br><span class="line">    <span class="attr">plugins</span>: [ <span class="comment">// 配置webpack插件  nuxt使用的webpack版本比较旧，有一些新功能无法使用</span></span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">__ENV__</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(process.<span class="property">env</span>.<span class="property">ENV</span> || <span class="string">&#x27;dev&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3>由于该项目与其他项目共用一个域名：www.###.com，需要保证另一个项目也可用。所有在部署的时候把Nuxt的项目放在了www.###.com/page目录下<br>在server中添加location /page的配置项<br>让根路径重定向到www.###.com/page/home<br>对旧项目已有的一些访问路径进行兼容<br>首页项目和旧项目（主站）的相互跳转（登录登出跳转等）<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3>一、document is not defined or window is not defined<br>解决方法：<br>此问题产生是由于在服务端渲染时使用了window或document等DOM相关的API，常见的原因有两个：</li>
<li>页面中生命周期使用错误，比如在created中使用了window<br>nuxt在服务端执行时会执行Vue生命周期中的beforeCreate和created，如果在这两个生命周期里使用了DOM相关的API是获取不到的，构建时会报错。</li>
<li>第三方插件使用了window或document等DOM相关的API<br>Nuxt.js 允许在运行Vue.js应用程序之前执行js插件。这在您需要使用自己的库或第三方模块时特别有用。但是要注意插件是否在客户端和服务端都需要，还有就是插件中是否用到了DOM相关的API（会导致构建时报错）<br>解决方法：</li>
<li>正确使用生命周期，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。<br>这里获取不到window或document等API，可以放在mounted中执行。</li>
<li>使用第三方插件时：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  &#123;</span><br><span class="line">    src: &#x27;~plugins/log.js&#x27;,</span><br><span class="line">    mode: &#x27;client&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
添加mode: ‘client’使第三方插件仅在客户端渲染时使用。<br>二、NuxtLink无法打开新页面<br>Nuxtjs中在进行路由导航时提供了<nuxt-link to="/"></nuxt-link>，但是此标签有一个问题：无法在新窗口打开链接，建议改为a标签，既能满足需求，也利于搜索引擎爬取相关链接。<br>三、注册全局方法<br>有时想在整个项目中使用函数或值，在Vue项目中我们有可能把方法挂在在Vue实例上，但是官方文档中明确提出：<br>请勿全局使用Vue.use()，Vue.component()，也不要在此功能内专门用于Nuxt注入的Vue中插入任何内容。这将导致服务器端内存泄漏。<br>另外也为我们提供了一种方法（inject(key, value)）来注册全局方法（变量）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// plugins/hello.js</span><br><span class="line">export default (&#123; app &#125;, inject) =&gt; &#123;</span><br><span class="line">  // Inject $hello(msg) in Vue, context and store.</span><br><span class="line">  inject(&#x27;hello&#x27;, msg =&gt; console.log(`Hello $&#123;msg&#125;!`))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">export default &#123;</span><br><span class="line">  plugins: [&#x27;~/plugins/hello.js&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后就可以在页面、组件、插件中使用了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$hello(&#x27;mounted&#x27;)</span><br><span class="line">    // will console.log &#x27;Hello mounted!&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  asyncData(&#123; app, $hello &#125;) &#123;</span><br><span class="line">    $hello(&#x27;asyncData&#x27;)</span><br><span class="line">    // If using Nuxt &lt;= 2.12, use 👇</span><br><span class="line">    app.$hello(&#x27;asyncData&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
四、Nuxt支持在页面中加入head信息。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;,</span><br><span class="line">  ...,</span><br><span class="line">  head () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#x27;&#x27;,</span><br><span class="line">      meta: [</span><br><span class="line">        &#123; hid: &#x27;&#x27;, name: &#x27;&#x27;, content: &#x27;&#x27;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
五、路由相关<br>Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。<br>基础路由<br>pages/</li>
</ul>
<p>–| user/<br>—–| index.vue<br>—–| one.vue<br>–| index.vue<br>那么，Nuxt.js 自动生成的路由配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router: &#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;index&#x27;,</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: &#x27;pages/index.vue&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;user&#x27;,</span><br><span class="line">      path: &#x27;/user&#x27;,</span><br><span class="line">      component: &#x27;pages/user/index.vue&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;user-one&#x27;,</span><br><span class="line">      path: &#x27;/user/one&#x27;,</span><br><span class="line">      component: &#x27;pages/user/one.vue&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套路由<br>你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。<br>创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。<br>文件路径：<br>pages/<br>–| users/<br>—–| _id.vue // 以下划线作为前缀的Vue文件：动态路由，做SSR的时候可能会用到<br>—–| index.vue<br>–| users.vue<br>Nuxt.js 自动生成的路由配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router: &#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/users&#x27;,</span><br><span class="line">      component: &#x27;pages/users.vue&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;&#x27;,</span><br><span class="line">          component: &#x27;pages/users/index.vue&#x27;,</span><br><span class="line">          name: &#x27;users&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;:id&#x27;,</span><br><span class="line">          component: &#x27;pages/users/_id.vue&#x27;,</span><br><span class="line">          name: &#x27;users-id&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>六、常用命令：<br>nuxt<br>启用一个热加载的Web服务器（开发模式）localhost:3000<br>nuxt build<br>利用webpack编译应用，压缩JS和CSS资源（发布用）。<br>nuxt start<br>以生产模式启动一个Web服务器 (基于dist目录，需要先执行nuxt build)。<br>nuxt generate<br>编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cropper</title>
    <url>/2023/04/11/vue-cropper/</url>
    <content><![CDATA[<h1 id="vue-cropper的使用"><a href="#vue-cropper的使用" class="headerlink" title="vue-cropper的使用"></a>vue-cropper的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-cropper --save</span><br></pre></td></tr></table></figure>
<h2 id="在main-js中引入"><a href="#在main-js中引入" class="headerlink" title="在main.js中引入"></a>在main.js中引入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueCropper from &#x27;vue-cropper&#x27;</span><br><span class="line">Vue.use(VueCropper)</span><br></pre></td></tr></table></figure>
<h1 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 图片裁剪组件 --&gt;</span><br><span class="line">    &lt;div class=&quot;img-cut&quot;&gt;</span><br><span class="line">      &lt;!-- 图片 --&gt;</span><br><span class="line">      &lt;div class=&quot;img-wrap&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;edit-img&quot; :src=&quot;imgUrl&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!-- 按钮 --&gt;</span><br><span class="line">      &lt;div class=&quot;btn-wrap&quot;&gt;</span><br><span class="line">        &lt;el-upload</span><br><span class="line">          ref=&quot;upload&quot;</span><br><span class="line">          :action=&quot;action&quot;</span><br><span class="line">          :auto-upload=&quot;false&quot;</span><br><span class="line">          :on-change=&quot;handleChange&quot;</span><br><span class="line">          :show-file-list=&quot;false&quot;</span><br><span class="line">          accept=&quot;image/*&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;button slot=&quot;trigger&quot; class=&quot;btn btn-white&quot;&gt;&#123;&#123; btnText &#125;&#125;&lt;/button&gt;</span><br><span class="line">        &lt;/el-upload&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!-- 图片裁剪 --&gt;</span><br><span class="line">      &lt;el-dialog</span><br><span class="line">        title=&quot;图片剪裁&quot;</span><br><span class="line">        :visible.sync=&quot;ImgdialogVisible&quot;</span><br><span class="line">        :modal=&quot;false&quot;</span><br><span class="line">        :close-on-click-modal=&quot;false&quot;</span><br><span class="line">        append-to-body</span><br><span class="line">        :destroy-on-close=&quot;true&quot;</span><br><span class="line">        :center=&quot;true&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div class=&quot;cropper-content&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;cropper&quot; style=&quot;text-align: center&quot;&gt;</span><br><span class="line">            &lt;vueCropper</span><br><span class="line">              ref=&quot;cropper&quot;</span><br><span class="line">              :img=&quot;option.img&quot;</span><br><span class="line">              :outputSize=&quot;option.size&quot;</span><br><span class="line">              :outputType=&quot;option.outputType&quot;</span><br><span class="line">              :info=&quot;option.info&quot;</span><br><span class="line">              :full=&quot;option.full&quot;</span><br><span class="line">              :canMove=&quot;option.canMove&quot;</span><br><span class="line">              :canMoveBox=&quot;option.canMoveBox&quot;</span><br><span class="line">              :original=&quot;option.original&quot;</span><br><span class="line">              :autoCrop=&quot;option.autoCrop&quot;</span><br><span class="line">              :fixed=&quot;option.fixed&quot;</span><br><span class="line">              :fixedNumber=&quot;option.fixedNumber&quot;</span><br><span class="line">              :centerBox=&quot;option.centerBox&quot;</span><br><span class="line">              :infoTrue=&quot;option.infoTrue&quot;</span><br><span class="line">              :fixedBox=&quot;option.fixedBox&quot;</span><br><span class="line">              :mode=&quot;option.mode&quot;</span><br><span class="line">              :canScale=&quot;option.canScale&quot;</span><br><span class="line">            &gt;</span><br><span class="line">            &lt;/vueCropper&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;button class=&quot;btn btn-white&quot; @click=&quot;ImgdialogVisible = false&quot;&gt;</span><br><span class="line">            取消</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">          &lt;button class=&quot;btn btn-red mleft-10&quot; @click=&quot;getSliceImg&quot;&gt;</span><br><span class="line">            保存并关闭</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/el-dialog&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    imgUrl: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    btnText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;选择图片&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      action: &#x27;/xxxx&#x27;,</span><br><span class="line">      ImgdialogVisible: false,</span><br><span class="line">      option: &#123;</span><br><span class="line">        img: &#x27;&#x27;, // 裁剪图片的地址</span><br><span class="line">        info: true, // 裁剪框的大小信息</span><br><span class="line">        outputSize: 0.8, // 裁剪生成图片的质量</span><br><span class="line">        outputType: &#x27;jpeg&#x27;, // 裁剪生成图片的格式</span><br><span class="line">        canScale: true, // 图片是否允许滚轮缩放</span><br><span class="line">        autoCrop: true, // 是否默认生成截图框</span><br><span class="line">        fixedBox: true, // 固定截图框大小 不允许改变</span><br><span class="line">        fixed: true, // 是否开启截图框宽高固定比例</span><br><span class="line">        fixedNumber: [1, 1], // 截图框的宽高比例</span><br><span class="line">        full: true, // 是否输出原图比例的截图</span><br><span class="line">        canMoveBox: false, // 截图框能否拖动</span><br><span class="line">        original: false, // 上传图片按照原始比例渲染</span><br><span class="line">        centerBox: true, // 截图框是否被限制在图片里面</span><br><span class="line">        infoTrue: true, // true 为展示真实输出图片宽高 false 展示看到的截图框宽高</span><br><span class="line">        mode: &#x27;contain&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getSliceImg () &#123;</span><br><span class="line">      this.$refs.cropper.getCropBlob(async (data) =&gt; &#123;</span><br><span class="line">        const imgSize = await this.getImgSize(data)</span><br><span class="line">        /* 把blob对象和最终图像的size传给父组件 */</span><br><span class="line">        this.$emit(&#x27;upload&#x27;, &#123; file: data, imgSize &#125;)</span><br><span class="line">        this.ImgdialogVisible = false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    /* 处理element upload组件change事件 */</span><br><span class="line">    handleChange (file) &#123;</span><br><span class="line">      this.openImgDialog(file.raw)</span><br><span class="line">    &#125;,</span><br><span class="line">    /* 打开裁剪页面 */</span><br><span class="line">    openImgDialog (file) &#123;</span><br><span class="line">      let reader = new FileReader()</span><br><span class="line">      reader.onload = (theFile) =&gt; &#123;</span><br><span class="line">        this.option.img = theFile.target.result</span><br><span class="line">        this.ImgdialogVisible = true</span><br><span class="line">      &#125;</span><br><span class="line">      if (file) &#123;</span><br><span class="line">        reader.readAsDataURL(file)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    /* 计算图片大小 */</span><br><span class="line">    getImgSize (file) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let reader = new FileReader()</span><br><span class="line">        reader.onload = function (theFile) &#123;</span><br><span class="line">          let image = new Image()</span><br><span class="line">          image.src = theFile.target.result</span><br><span class="line">          image.onload = function () &#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">              width: this.width,</span><br><span class="line">              height: this.height</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (file) &#123;</span><br><span class="line">          reader.readAsDataURL(file)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject(&#x27;出错了&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>问题一、如何阻止upload上传完之后就上传？　　<br>将el-upload 的 auto-upload 设置为 false即可<br>问题二、如何将获取到文件传给vue-cropper?　　<br>vue-cropper 可以接受一个 blob，此时需要 new FileReader()，参考 MDN<br>问题三、el-upload 选择完文件后不能更改，如何上传裁剪之后的图片？<br>使用自定义上传，点击上传时直接调用submit 方法，这时会自动触发http-request中的自定义方法，可以拿到file中的所有属性，在函数里面使用 axios 自定义上传参数和文件。此方法比较好控制。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-cropper</tag>
      </tags>
  </entry>
  <entry>
    <title>component动态组件</title>
    <url>/2023/03/23/component%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一、什么是动态组件？"><a href="#一、什么是动态组件？" class="headerlink" title="一、什么是动态组件？"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is="componentName"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p>
<h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;reload&quot;&gt;点击切换&lt;/div&gt; </span><br><span class="line">&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import childOne from &#x27;./childOne&#x27;</span><br><span class="line">import childTwo from &#x27;./childTwo&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    componets:&#123;</span><br><span class="line">        childOne,</span><br><span class="line">        childTwo</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        currentTabComponent: &#x27;childOne&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        reload()&#123;</span><br><span class="line">            this.currentTabComponent = &#x27;childTwo&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="三、动态组件的缓存"><a href="#三、动态组件的缓存" class="headerlink" title="三、动态组件的缓存"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。<br>大白话:比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话,列表和详情都是一个使用频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3</title>
    <url>/2022/10/10/vue3/</url>
    <content><![CDATA[<h1 id="vue3-简介"><a href="#vue3-简介" class="headerlink" title="vue3 简介"></a>vue3 简介</h1><ol>
<li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li>
<li>3.0版本的vue，开发周期长达两年多。</li>
<li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id="Vue3-的优势"><a href="#Vue3-的优势" class="headerlink" title="Vue3 的优势"></a>Vue3 的优势</h1></li>
<li>3比2要快将近两倍。</li>
<li>3加入了TS以及对PWA的支持。</li>
<li>3没有beforeCreate、created，用setup代替。</li>
<li>单独功能可以抽离，比如watch、component。</li>
<li>没有眼花缭乱的this。</li>
<li>强大的proxy实现响应式。</li>
<li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li>
<li>3的组合式API可以和2的 optionAPI同时存在。</li>
<li>代码更利于维护和封装。</li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3-hooks使用</title>
    <url>/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="我们来说一下vue3-项目中的-hooks-的使用"><a href="#我们来说一下vue3-项目中的-hooks-的使用" class="headerlink" title="我们来说一下vue3 项目中的 hooks 的使用"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p>
<h1 id="我们先看一下hooks优点有哪些？"><a href="#我们先看一下hooks优点有哪些？" class="headerlink" title="我们先看一下hooks优点有哪些？"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p>
<ol>
<li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li>
<li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li>
<li>hooks 函数可以与 mixin 连用，但是不建议。</li>
</ol>
<h1 id="hooks-基本使用"><a href="#hooks-基本使用" class="headerlink" title="hooks 基本使用"></a>hooks 基本使用</h1><p><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p>
<h1 id="我们针对上面的案例，我们使用-hooks-简单的实现一下。"><a href="#我们针对上面的案例，我们使用-hooks-简单的实现一下。" class="headerlink" title="我们针对上面的案例，我们使用 hooks 简单的实现一下。"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3+vite中怎么解析md文档</title>
    <url>/2023/05/15/vue3-vite%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A7%A3%E6%9E%90md%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="「摘要」"><a href="#「摘要」" class="headerlink" title="「摘要」"></a>「摘要」</h1><p>Vue的markdown解析库有很多，如markdown-it、vue-markdown-loader、marked、vue-markdown等，这些库都大同小异。这篇文章主要介绍了vue3+vite中怎么解析markdown文档并实现代码高亮显示。这里选用的是markdown-it，代码高亮的库选用的是highlight.js。</p>
<h1 id="「一、安装依赖库」"><a href="#「一、安装依赖库」" class="headerlink" title="「一、安装依赖库」"></a>「一、安装依赖库」</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install markdown-it --save   // markdown-it 用于将markdown转换成html</span><br><span class="line">npm install highlight.js -save   //用于代码高亮显示</span><br></pre></td></tr></table></figure>
<h1 id="「二、引入」"><a href="#「二、引入」" class="headerlink" title="「二、引入」"></a>「二、引入」</h1><p>在main.ts文件中引入highlight.js及样式并创建一个自定义的全局指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hljs from &#x27;highlight.js&#x27;;</span><br><span class="line">import &#x27;highlight.js/styles/atom-one-dark.css&#x27; //样式</span><br><span class="line">//创建v-highlight全局指令</span><br><span class="line">Vue.directive(&#x27;highlight&#x27;,function (el) &#123;</span><br><span class="line">  let blocks = el.querySelectorAll(&#x27;pre code&#x27;);</span><br><span class="line">  blocks.forEach((block)=&gt;&#123;</span><br><span class="line">    hljs.highlightBlock(block)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析vue项目中npm run dev和npm run serve的区别</title>
    <url>/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？"><a href="#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？" class="headerlink" title="先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p>
<h2 id="在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。"><a href="#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。" class="headerlink" title="在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id="首先看看npm是什么？"><a href="#首先看看npm是什么？" class="headerlink" title="首先看看npm是什么？"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p>
<h1 id="在看看npm-install命令"><a href="#在看看npm-install命令" class="headerlink" title="在看看npm install命令"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p>
<h1 id="然后看看运行npm-run-×××命令的原理"><a href="#然后看看运行npm-run-×××命令的原理" class="headerlink" title="然后看看运行npm run ×××命令的原理"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src="/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<hr>
<p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p>
<h1 id="既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？"><a href="#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？" class="headerlink" title="既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3新语法细节</title>
    <url>/2023/01/10/vue3%E6%96%B0%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p>
<p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p>
<p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p>
<p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p>
<p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p>
<p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p>
<p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p>
<p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p>
<p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p>
<p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p>
<p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p>
<p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p>
<p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p>
<p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p>
<p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3ref和reactive函数</title>
    <url>/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ref-函数介绍"><a href="#ref-函数介绍" class="headerlink" title="ref 函数介绍"></a>ref 函数介绍</h1><ol>
<li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li>
<li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li>
<li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li>
<li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li>
<li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li>
</ol>
<h2 id="ref-函数使用"><a href="#ref-函数使用" class="headerlink" title="ref 函数使用"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p>
<h2 id="ref-函数处理基本数据类型"><a href="#ref-函数处理基本数据类型" class="headerlink" title="ref 函数处理基本数据类型"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>修改代码：<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>码刷新页面查看效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p>
<h2 id="ref-函数处理复杂数据类型"><a href="#ref-函数处理复杂数据类型" class="headerlink" title="ref 函数处理复杂数据类型"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>我们修改也通过 value 进行操作<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>刷新页面，查看效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="ref-函数获取单个DOM元素"><a href="#ref-函数获取单个DOM元素" class="headerlink" title="ref 函数获取单个DOM元素"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>运行效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="reactive-函数介绍"><a href="#reactive-函数介绍" class="headerlink" title="reactive 函数介绍"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p>
<h2 id="reactive-函数使用"><a href="#reactive-函数使用" class="headerlink" title="reactive 函数使用"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="reactive-函数处理数组"><a href="#reactive-函数处理数组" class="headerlink" title="reactive 函数处理数组"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3API</title>
    <url>/2022/12/13/vue3API/</url>
    <content><![CDATA[<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p>
<p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p>
<p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p>
<p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack之require.context</title>
    <url>/2023/05/06/webpack%E4%B9%8Brequire-context/</url>
    <content><![CDATA[<h1 id="了解webpack的require-context"><a href="#了解webpack的require-context" class="headerlink" title="了解webpack的require.context"></a>了解webpack的require.context</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>src/icons/index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const context = require.context(&quot;./svg&quot;, true, /\.svg$/)</span><br><span class="line">context.keys().map(context)</span><br></pre></td></tr></table></figure>
<p>main.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;@/icons&#x27;</span><br></pre></td></tr></table></figure>
<p>webpack.base.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.svg$/,</span><br><span class="line">    loader: &quot;svg-sprite-loader&quot;,</span><br><span class="line">    include: [resolve(&quot;src/icons&quot;)],</span><br><span class="line">    options: &#123;</span><br><span class="line">        symbolId: &quot;icon-[name]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">    loader: &quot;url-loader&quot;,</span><br><span class="line">    exclude: [resolve(&quot;src/icons&quot;)],</span><br><span class="line">    options: &#123;</span><br><span class="line">        limit: 10000,</span><br><span class="line">        name: utils.assetsPath(&quot;img/[name].[hash:7].[ext]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h2><p>很多人跟我一样，一开始只想说，为什么这样就可以，why???</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const context = require.context(&quot;./svg&quot;, true, /\.svg$/)</span><br><span class="line">// 看看你是何方神圣</span><br><span class="line">console.log(context)</span><br><span class="line">context.keys().map(context)</span><br></pre></td></tr></table></figure>
<p>看下面的图，理解一下<br><img src="/2023/05/06/webpack%E4%B9%8Brequire-context/image.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3组件传值</title>
    <url>/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="父子组件传值-props"><a href="#父子组件传值-props" class="headerlink" title="父子组件传值 props"></a>父子组件传值 props</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="祖孙组件传值-provide-和-inject"><a href="#祖孙组件传值-provide-和-inject" class="headerlink" title="祖孙组件传值 provide 和 inject"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="父组件中点击按钮向子组件传值"><a href="#父组件中点击按钮向子组件传值" class="headerlink" title="父组件中点击按钮向子组件传值"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2022/08/30/webpack/</url>
    <content><![CDATA[<h1 id="webpack-打包原理是什么？"><a href="#webpack-打包原理是什么？" class="headerlink" title="webpack 打包原理是什么？"></a>webpack 打包原理是什么？</h1><h2 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h2><p>webpack 打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack 处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个 bundle。</p>
<h1 id="webpack-构建流程："><a href="#webpack-构建流程：" class="headerlink" title="webpack 构建流程："></a>webpack 构建流程：</h1><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p>
<h1 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h1><h2 id="代码层面："><a href="#代码层面：" class="headerlink" title="代码层面："></a>代码层面：</h2><ol>
<li>体积更小，加载更快</li>
<li>编译高级语言和语法</li>
<li>兼容性和错误检查</li>
</ol>
<h2 id="研发流程层面："><a href="#研发流程层面：" class="headerlink" title="研发流程层面："></a>研发流程层面：</h2><ol>
<li>统一高效的开发环境</li>
<li>统一的构建流程和产出标准</li>
<li>集成公司构建规范（提测、上线）</li>
</ol>
<h1 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h1><p>entry：入口，webpack 的执行从 entry 开始，<br>output：出口，输出结果，webpack 的输出位置，<br>loader：模块转换器，用于把 webpack 不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容<br>mode：通过选择 development 或者 production 来设置 mode 参数<br>chunk：代码块，即打包后输出的文件</p>
<h1 id="基本功能和工作原理"><a href="#基本功能和工作原理" class="headerlink" title="基本功能和工作原理"></a>基本功能和工作原理</h1><p>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</p>
<ol>
<li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li>
<li>文件优化：压缩文件代码、压缩合并图片等</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li>
<li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li>
<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>
<li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="1、loader-和-plugin-的区别："><a href="#1、loader-和-plugin-的区别：" class="headerlink" title="1、loader 和 plugin 的区别："></a>1、loader 和 plugin 的区别：</h2><h3 id="不同的作用："><a href="#不同的作用：" class="headerlink" title="不同的作用："></a>不同的作用：</h3><p>loader：webpack 将一切文件视为模块，但是 webpack 原生只能解析 JS 文件，如果想打包其他文件的话，就会用到相应的 loader，它是用来让 webpack 拥有加载解析非 JS 文件的工具<br>plugins：插件，可以扩展 webpack 的功能，让其更具有灵活性</p>
<h3 id="不同的用法："><a href="#不同的用法：" class="headerlink" title="不同的用法："></a>不同的用法：</h3><p>loader：在 module.rules 中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象<br>plugins: 在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入</p>
<h3 id="2、什么是模块化，为什么要用模块化"><a href="#2、什么是模块化，为什么要用模块化" class="headerlink" title="2、什么是模块化，为什么要用模块化"></a>2、什么是模块化，为什么要用模块化</h3><p>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现很多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码</p>
<h3 id="3、DevServer-开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。"><a href="#3、DevServer-开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。" class="headerlink" title="3、DevServer 开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。"></a>3、DevServer 开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 3000,</span><br><span class="line">    open: true,</span><br><span class="line">    // 开启HMR功能</span><br><span class="line">    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、什么是-HMR-功能"><a href="#4、什么是-HMR-功能" class="headerlink" title="4、什么是 HMR 功能"></a>4、什么是 HMR 功能</h3><p>HMR 又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式</p>
<h3 id="5、什么是-Tree-sharking"><a href="#5、什么是-Tree-sharking" class="headerlink" title="5、什么是 Tree-sharking?"></a>5、什么是 Tree-sharking?</h3><p>Tree-sharking 指打包中去除那些引入了但在代码中没用到的死代码（传统的 DCE 方法是除去不可能执行的代码）包括空格、注释等</p>
<h3 id="6、babel-和-webpack-的区别"><a href="#6、babel-和-webpack-的区别" class="headerlink" title="6、babel 和 webpack 的区别"></a>6、babel 和 webpack 的区别</h3><p>babel： JS 新语法编译工具，只关心语法，不关心模块化<br>webpack： 打包构建工具，是多个 Loader、 plugin 的集合</p>
<h3 id="7、类似-webpack-的工具还有哪些"><a href="#7、类似-webpack-的工具还有哪些" class="headerlink" title="7、类似 webpack 的工具还有哪些"></a>7、类似 webpack 的工具还有哪些</h3><p>webpack 适用于大型复杂的前端站点构建<br>rollup 适用于基础库的打包，如 vue、react<br>parcel 适用于简单的实验性项目，它可以满足低门槛的快速看到效果由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel</p>
<h3 id="8、常见-loader"><a href="#8、常见-loader" class="headerlink" title="8、常见 loader"></a>8、常见 loader</h3><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>image-loader：加载并且压缩图片文件<br>babel-loader：把 ES6 转换成 ES5<br>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS<br>eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
<h3 id="9、常见的-plugins"><a href="#9、常见的-plugins" class="headerlink" title="9、常见的 plugins"></a>9、常见的 plugins</h3><p>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack升级</title>
    <url>/2023/04/05/webpack%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>由于项目越来越庞大复杂，打包时间也非常长，本地开发环境每次重启都要打包好久，正好借此契机对webpack做了一个升级。</p>
<h1 id="二、webpack5-和-webpack4-的区别有哪些-？"><a href="#二、webpack5-和-webpack4-的区别有哪些-？" class="headerlink" title="二、webpack5 和 webpack4 的区别有哪些 ？"></a>二、webpack5 和 webpack4 的区别有哪些 ？</h1><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>如果我们的项目中引入了lodash包，但是我只用了其中的一个方法。其他没有用到的方法是不是冗余的？此时tree-shaking就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。<br>usedExports : true, 标记没有用的叶子<br>minimize: true, 摇掉那些没有用的叶子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.config.js中</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">     optimization: &#123;</span><br><span class="line">       usedExports: true, //只导出被使用的模块</span><br><span class="line">       minimize : true // 启动压缩</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于tree shaking只支持esmodule ，如果你打包出来的是commonjs，此时tree-shaking就失效了。不过当前大家都用的是vue，react等框架，他们都是用babel-loader编译，以下配置就能够保证他一定是esmodule。<br><img src="/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>webpack5的 mode=“production” 自动开启 tree-shaking。</p>
<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><ul>
<li>webpack4<br>webpack4需要下载安装terser-webpack-plugin 插件，并且需要以下配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123; </span><br><span class="line">// ...other config</span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimize: !isDev,</span><br><span class="line">  minimizer: [</span><br><span class="line">    new TerserPlugin(&#123;</span><br><span class="line">      extractComments: false, </span><br><span class="line">      terserOptions: &#123; </span><br><span class="line">        compress: &#123; </span><br><span class="line">          pure_funcs: [&#x27;console.log&#x27;] </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>webpack5<br>内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。<br>如果你要在开发环境使用，就用下面：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.config.js中</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">     optimization: &#123;</span><br><span class="line">       usedExports: true, //只导出被使用的模块</span><br><span class="line">       minimize : true // 启动压缩</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>js 压缩失效问题<br>当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">  optimization: &#123; </span><br><span class="line">    minimizer: [ </span><br><span class="line">      new OptimizeCssAssetsPlugin() </span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时的压缩插件optimize-css-assets-webpack-plugin可以配置到plugins里面去，也可以如图配置到到 optimization里面。区别如下：<br>配置到plugins中，那么这个插件在任何情况下都会工作。而配置在optimization表示只有minimize为 true 的时候才能工作。<br>当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是optimize-css-assets-webpack-plugin<br>导致默认的terser-webpack-plugin就会失效。解决办法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install terser-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: false,</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          compress: &#123; pure_funcs: [&#x27;console.log&#x27;] &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      new OptimiazeCssAssetPlugin(),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
即便在webpack5中，你也要像webpack4中一样使用js压缩。</li>
<li>注意事项<br>在webpack5里面使用optimize-css-assets-webpack-plugin会报错，因为官方已经打算要废除了，请使用替换方案：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<h2 id="合并模块"><a href="#合并模块" class="headerlink" title="合并模块"></a>合并模块</h2>普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules可以要所有的模块都合并到一个函数里面去。<br>optimization.concatenateModules = true<br>配置如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports: true,</span><br><span class="line">    concatenateModules: true,</span><br><span class="line">    minimize: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时配合 tree-shaking 你会发现打包的体积会减小很多。<h2 id="副作用sideEffects"><a href="#副作用sideEffects" class="headerlink" title="副作用sideEffects"></a>副作用sideEffects</h2></li>
<li>webpack4 新增了一个sideEffects的功能，允许我们通过配置来标识我们的代码是否有副作用。这个特性只有在开发npm包的时候用到。</li>
<li>副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少，不管utils里面有多少方法，我都只需要引入utils即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// utils/index.js</span><br><span class="line">  export * from &#x27;./getXXX.js&#x27;;</span><br><span class="line">  export * from &#x27;./getAAA.js&#x27;;</span><br><span class="line">  export * from &#x27;./getBBB.js&#x27;;</span><br><span class="line">  export * from &#x27;./getCCC.js&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在其他文件使用 getXXX 引入</span><br><span class="line"> import &#123;getXX&#125; from &#x27;../utils&#x27;</span><br></pre></td></tr></table></figure></li>
<li>此时，如果文件getAAA在外界没有用到，而tree-shaking又不能把它摇掉怎么办？</li>
<li>这个getAAA就是副作用。你或许要问tree-shaking为什么不能把它摇掉？</li>
<li>原因就是：他在utils/index.js 里面使用了。只能开启副作用特性。如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// package.json中</span><br><span class="line">&#123;</span><br><span class="line">  name：“项目名称”,</span><br><span class="line">  ....</span><br><span class="line">  sideEffects: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;none&#x27;,</span><br><span class="line">  ....</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    sideEffects: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>副作用开启：<br>(1)optimization.sideEffects = true 开启副作用功能<br>(2)package.json 中设置 sideEffects : false 标记所有模块无副作用</li>
<li>说明：<br>webpack打包前都会检查项目所属的package.json文件中的sideEffects标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js里面开启sideEffects。<h2 id="webpack-缓存"><a href="#webpack-缓存" class="headerlink" title="webpack 缓存"></a>webpack 缓存</h2></li>
<li>webpack4缓存配置<br>支持缓存在内存中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hard-source-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;) </span><br><span class="line">module.exports = &#123; </span><br><span class="line">plugins: [</span><br><span class="line">  // 其它 plugin... </span><br><span class="line">  new HardSourceWebpackPlugin(), </span><br><span class="line">] &#125;</span><br></pre></td></tr></table></figure></li>
<li>webpack5缓存配置<br>webpack5内部内置了cache缓存机制，直接配置即可。<br>cache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports= &#123;</span><br><span class="line">  // 使用持久化缓存</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: &#x27;filesystem&#x27;，</span><br><span class="line">    cacheDirectory: path.join(__dirname, &#x27;node_modules/.cac/webpack&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>type的可选值为：memory使用内容缓存，filesystem使用文件缓存。</li>
<li>当type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里。<h2 id="对loader的优化"><a href="#对loader的优化" class="headerlink" title="对loader的优化"></a>对loader的优化</h2>webpack4加载资源需要用不同的loader</li>
<li>raw-loader将文件导入为字符串</li>
<li>url-loader将文件作为data url内联到bundle文件中</li>
<li>file-loader将文件发送到输出目录中<br><img src="/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>webpack5 的资源模块类型替换 loader<br>资源模块类型(asset module type)，通过添加4种新的模块类型，来替换所有这些 loader：</li>
<li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</li>
<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。</li>
<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。</li>
<li>asset 在导出一个data URI和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。<br><img src="/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-2.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><h2 id="启动服务的差别"><a href="#启动服务的差别" class="headerlink" title="启动服务的差别"></a>启动服务的差别</h2></li>
<li>webpack4 启动服务<br>通过webpack-dev-server启动服务</li>
<li>webpack5 启动服务<br>内置使用webpack serve启动，但是它的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化。<h2 id="devtool的差别"><a href="#devtool的差别" class="headerlink" title="devtool的差别"></a>devtool的差别</h2>sourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。<br>一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。<br>devtool在webpack4和webpack5上也是有区别的<br>v4: devtool: ‘cheap-eval-module-source-map’<br>v5: devtool: ‘eval-cheap-module-source-map’<h2 id="热更新差别"><a href="#热更新差别" class="headerlink" title="热更新差别"></a>热更新差别</h2></li>
<li>webpack4设置<br><img src="/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-3.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>webpack5设置<br>如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.hot.accept(&#x27;需要热启动的文件&#x27;,(source)=&gt;&#123;</span><br><span class="line">    //自定义热启动</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。<br>如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。<br>只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：<br><img src="/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack5-1.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><h2 id="使用-webpack-merge-的差别"><a href="#使用-webpack-merge-的差别" class="headerlink" title="使用 webpack-merge 的差别"></a>使用 webpack-merge 的差别</h2></li>
<li>webpack4 导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const merge = require(&#x27;webpack-merge);</span><br></pre></td></tr></table></figure></li>
<li>webpack 5 导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="使用-copy-webpack-plugin-的差别"><a href="#使用-copy-webpack-plugin-的差别" class="headerlink" title="使用 copy-webpack-plugin 的差别"></a>使用 copy-webpack-plugin 的差别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // webpack 4</span><br><span class="line">    new CopyWebpackPlugin([&#x27;public&#x27;]),   </span><br><span class="line">    // webpack 5</span><br><span class="line">    new CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [&#123;</span><br><span class="line">        from: &#x27;./public&#x27;,</span><br><span class="line">        to: &#x27;./dist/public&#x27;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
webpack5支持的新版本里面需要配置的更加清楚。<h1 id="三、升级过程"><a href="#三、升级过程" class="headerlink" title="三、升级过程"></a>三、升级过程</h1>Webpack5对Node.js的版本要求至少是10.13.0<h2 id="先升级-webpack-和-webpack-cli"><a href="#先升级-webpack-和-webpack-cli" class="headerlink" title="先升级 webpack 和 webpack-cli"></a>先升级 webpack 和 webpack-cli</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">npm install <span class="attr">--save-dev</span> webpack<span class="keyword">@latest</span> webpack-cli<span class="keyword">@latest</span>  webpack-dev-server<span class="keyword">@latest</span> webpack-merge<span class="keyword">@latest</span></span><br></pre></td></tr></table></figure>
webpack-merge升级以后，使用方式改为如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br></pre></td></tr></table></figure>
升级所有使用到的plugin和loader为最新的可用版本。<br>部分plugin和loader可能会有一个beta版本，必须使用它们才能与webpack 5兼容。<h2 id="执行npm-start"><a href="#执行npm-start" class="headerlink" title="执行npm start"></a>执行npm start</h2>在 package.json中scripts的start命令如下：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --colors  --config ./webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="–colors-报错"><a href="#–colors-报错" class="headerlink" title="–colors 报错"></a>–colors 报错</h3>在v4版本中，我们可以使用 –colors或者 –color，但是在v5版本中只能使用 –color<br>调整命令：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --color  --config ./webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="devServer-中-disableHostCheck报错"><a href="#devServer-中-disableHostCheck报错" class="headerlink" title="devServer 中 disableHostCheck报错"></a>devServer 中 disableHostCheck报错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    ... </span><br><span class="line">    disableHostCheck: true, </span><br><span class="line">    ... </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
修改为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    ... </span><br><span class="line">    allowedHosts: &quot;all&quot;, </span><br><span class="line">    ... </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
当设置为 ‘all’ 时会跳过host检查。并不推荐这样做，因为不检查host的应用程序容易受到DNS重绑定攻击。<h3 id="vue-loader问题"><a href="#vue-loader问题" class="headerlink" title="vue-loader问题"></a>vue-loader问题</h3>注意 vue-loader不同的版本是对应VUE不同版本的，这里一定要注意，如果你的VUE版本是2.x那么你要使用<a href="mailto:&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#100;&#101;&#114;&#x40;&#49;&#x35;&#46;&#x78;">&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#100;&#101;&#114;&#x40;&#49;&#x35;&#46;&#x78;</a>，如果是<a href="mailto:&#x76;&#x75;&#x65;&#64;&#51;&#x2e;&#120;">&#x76;&#x75;&#x65;&#64;&#51;&#x2e;&#120;</a>那么要使用<a href="mailto:&#x76;&#117;&#101;&#x2d;&#x6c;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#x36;&#46;&#120;">&#x76;&#117;&#101;&#x2d;&#x6c;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#x36;&#46;&#120;</a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue-loader@16.x</span></span><br><span class="line"><span class="comment">// 对应vue@3.x</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vue-loader@15.x</span></span><br><span class="line"><span class="comment">// 对应vue@2.x</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="119-101-x62-112-97-99-107-64-53-46-120-与-118-x75-101-x2d-108-111-x61-x64-101-x72-64-x31-x36-x2e-120-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题"><a href="#119-101-x62-112-97-99-107-64-53-46-120-与-118-x75-101-x2d-108-111-x61-x64-101-x72-64-x31-x36-x2e-120-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题" class="headerlink" title="&#119;&#101;&#x62;&#112;&#97;&#99;&#107;&#64;&#53;&#46;&#120;与&#118;&#x75;&#101;&#x2d;&#108;&#111;&#x61;&#x64;&#101;&#x72;&#64;&#x31;&#x36;&#x2e;&#120;版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题"></a><a href="mailto:&#119;&#101;&#x62;&#112;&#97;&#99;&#107;&#64;&#53;&#46;&#120;">&#119;&#101;&#x62;&#112;&#97;&#99;&#107;&#64;&#53;&#46;&#120;</a>与<a href="mailto:&#118;&#x75;&#101;&#x2d;&#108;&#111;&#x61;&#x64;&#101;&#x72;&#64;&#x31;&#x36;&#x2e;&#120;">&#118;&#x75;&#101;&#x2d;&#108;&#111;&#x61;&#x64;&#101;&#x72;&#64;&#x31;&#x36;&#x2e;&#120;</a>版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题</h3>解决方案</li>
</ul>
<ol>
<li>DescriptionDataMatcherRulePlugin是出现在vue-loader里面的</li>
<li>webpack@5里面为啥不见了，我去webpack源码里找，竟然把文件名给改了，然后vue-loader那边没有同步修改</li>
<li>解决方案：npm i <a href="mailto:&#119;&#101;&#98;&#112;&#x61;&#99;&#x6b;&#x40;&#x35;&#x2e;&#x34;&#x34;&#x2e;&#x30;">&#119;&#101;&#98;&#112;&#x61;&#99;&#x6b;&#x40;&#x35;&#x2e;&#x34;&#x34;&#x2e;&#x30;</a> -D 或者等vue-loader 更新<h3 id="postcss-loader-问题"><a href="#postcss-loader-问题" class="headerlink" title="postcss-loader 问题"></a>postcss-loader 问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev autoprefixer</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新的配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(c|sa|sc)ss$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                     <span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="comment">// &lt;style&gt;&lt;/style&gt; 插入页面,development下使用</span></span><br><span class="line">                     <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                                <span class="attr">plugins</span>: [</span><br><span class="line">                                    [</span><br><span class="line">                                        <span class="comment">// &quot;postcss-preset-env&quot;, // postcss-preset-env 包含autoprefixer （npm install postcss-preset-env --save-dev）</span></span><br><span class="line">                                        <span class="comment">// &quot;postcss-nested&quot;,</span></span><br><span class="line">                                        <span class="string">&quot;autoprefixer&quot;</span>, <span class="comment">// css 加前缀</span></span><br><span class="line">                                    ],</span><br><span class="line">                                ],</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">                     </span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="optimization-配置"><a href="#optimization-配置" class="headerlink" title="optimization 配置"></a>optimization 配置</h3>production<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="comment">// 告知 webpack 当选择模块 id 时需要使用哪种算法</span></span><br><span class="line">        <span class="attr">moduleIds</span>: <span class="string">&#x27;deterministic&#x27;</span> <span class="comment">// 被哈希转化成的小位数值模块名。</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webpack-manifest-plugin"><a href="#webpack-manifest-plugin" class="headerlink" title="webpack-manifest-plugin"></a>webpack-manifest-plugin</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WebpackManifestPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-manifest-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebpackManifestPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">filter</span>: <span class="keyword">function</span> (<span class="params">FileDescriptor</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">FileDescriptor</span>.<span class="property">isChunk</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【vite+vue3+Ts+element-plus1】</title>
    <url>/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/</url>
    <content><![CDATA[<h1 id="使用vite初始化项目"><a href="#使用vite初始化项目" class="headerlink" title="使用vite初始化项目"></a>使用vite初始化项目</h1><p>首先我们使用vite来初始化项目，vite支持使用npm、yarn和pnpm来初始化项目，本文采用npm的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用npm</span><br><span class="line">npm create vite@latest</span><br><span class="line">// 使用yarn</span><br><span class="line">yarn create vite</span><br><span class="line">// 使用pnpm</span><br><span class="line">pnpm create vite</span><br></pre></td></tr></table></figure>
<p>输入命令之后会提示我们输入项目名，如果我们已经建好项目，并且是在项目根目录执行的命令的话，只需输入一个点表示在当前目录创建就行，需要注意的是当前项目文件夹必须是空文件夹，否则vite会提示你是否清空已存在的文件继续。<br>如果还没建项目，是在父目录执行的命令，则需输入要创建的项目名<br>之后会让我们选择使用的框架和选择使用js还是ts，我们选择vue和ts。<br>之后我们按照提示命令进入项目目录执行命令安装依赖，运行项目即可。<br>之后我们把一些默认的没用的文件给干掉，再在相关引用的地方把引用给清空。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/qingkong.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>再把APP.vue里面的内容给清空，这个时候整个项目就是干干净净的了。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/qingkongapp.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="vscode推荐插件"><a href="#vscode推荐插件" class="headerlink" title="vscode推荐插件"></a>vscode推荐插件</h1><p>使用vscode的用户注意了，之前我们开发vue可能使用的是vetur插件，但是从vue3开始，官方已经推荐使用Volar了，所以我们需要把旧的插件给禁用或者直接卸载掉。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/vetur.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>再去扩展里搜索volar进行安装就可以了。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/volar.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="vite配置目录别名"><a href="#vite配置目录别名" class="headerlink" title="vite配置目录别名"></a>vite配置目录别名</h1><p>在项目开发中，我们通常会引用其他目录的文件，但如果文件不在一个目录的话，就会使用../的方式去查找，如果层级多的话很不方便，所以我们通常会给一些常用目录配置一个别名，比如下面我们就在vite中给src目录配置一个‘@’别名<br>首先我们需要安装node的类型声明文件，要不然ts可能会报警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add @types/node -D</span><br></pre></td></tr></table></figure>
<p>之后我们在vite.config.ts中进行相关配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class="line">import path from &#x27;path&#x27;                   // 增加此行代码</span><br><span class="line">const pathSrc = path.resolve(__dirname, &#x27;src&#x27;)</span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">  ],</span><br><span class="line">  resolve: &#123;                              </span><br><span class="line">    alias: &#123;              // 增加此行代码                </span><br><span class="line">      &#x27;@&#x27;: pathSrc,</span><br><span class="line">    &#125;,                                </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>之后还要在tsconfig.json中增加以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;paths&quot;: &#123;</span><br><span class="line">     &quot;@/*&quot;: [&quot;./src/*&quot;]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="重置默认样式"><a href="#重置默认样式" class="headerlink" title="重置默认样式"></a>重置默认样式</h1><p>我们这里直接在assets/style文件夹下新建一个normalize.css，写入重置样式。<br>然后在main.ts中引入即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import &#x27;@/assets/style/normalize.css&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>首先我们来安装一下vue-router</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add vue-router@4</span><br></pre></td></tr></table></figure>
<p>之后在src目录下新建router/index.ts，写入一些基本路由。<br>这里需要注意的是，vue-router指定路由模式从字符串变为了使用方法，history是createWebHistory(地址栏不带#)，hash是createWebHashHistory（地址栏带#）。<br>这时候我们可能还会发现，编辑器中ts会报找不到vue文件相关类型声明的错误。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/router.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="解决办法：我们可以在根目录创建一个env-d-ts，在里面写入以下内容"><a href="#解决办法：我们可以在根目录创建一个env-d-ts，在里面写入以下内容" class="headerlink" title="解决办法：我们可以在根目录创建一个env.d.ts，在里面写入以下内容"></a>解决办法：我们可以在根目录创建一个env.d.ts，在里面写入以下内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span><br><span class="line">declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">  //引入vue模块中ts的方法</span><br><span class="line">  import type &#123; DefineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">  // 定义vue組件以及类型注解</span><br><span class="line">  const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt;</span><br><span class="line">  export default component</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后还要记得在tsconfig.ts中引入。<br><img src="/2023/04/26/%E3%80%90vite-vue3-Ts-element-plus1%E3%80%91/ts.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>现在报错没有了，我们还需要在main.ts中进行引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">createApp(App).use(router).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vite</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2022/08/16/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h1><h1 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2.初始化项目"></a>2.初始化项目</h1><h2 id="现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。"><a href="#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。" class="headerlink" title="现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id="初始化生成blog项目"><a href="#初始化生成blog项目" class="headerlink" title="// 初始化生成blog项目"></a>// 初始化生成blog项目</h2><p>hexo init blog</p>
<h1 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3.配置主题"></a>3.配置主题</h1><h2 id="hexo默认的主题是-landscape，现在我们将主题配置为-keep。"><a href="#hexo默认的主题是-landscape，现在我们将主题配置为-keep。" class="headerlink" title="hexo默认的主题是_landscape，现在我们将主题配置为 keep。"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id="确认目录是否切换到了blog中，如果没有，则将目录切换到blog中"><a href="#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中" class="headerlink" title="// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p>
<h2 id="安装keep主题"><a href="#安装keep主题" class="headerlink" title="// 安装keep主题"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p>
<h2 id="修改-config-yml配置文件"><a href="#修改-config-yml配置文件" class="headerlink" title="// 修改_config.yml配置文件"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href="http://localhost:4000/">http://localhost:4000</a></p>
<h1 id="4-添加文章"><a href="#4-添加文章" class="headerlink" title="4.添加文章"></a>4.添加文章</h1><h2 id="现在，让我们新建一篇博客"><a href="#现在，让我们新建一篇博客" class="headerlink" title="现在，让我们新建一篇博客"></a>现在，让我们新建一篇博客</h2><h2 id="在blog项目中，执行如下命令：新建文章"><a href="#在blog项目中，执行如下命令：新建文章" class="headerlink" title="// 在blog项目中，执行如下命令：新建文章"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p>
<h2 id="新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。"><a href="#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。" class="headerlink" title="新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h2 id="添加正文"><a href="#添加正文" class="headerlink" title="添加正文"></a>添加正文</h2><h2 id="现在我们打开【xxxx-md】，写下我们的xxxxx。"><a href="#现在我们打开【xxxx-md】，写下我们的xxxxx。" class="headerlink" title="现在我们打开【xxxx.md】，写下我们的xxxxx。"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id="然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了"><a href="#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了" class="headerlink" title="然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了"></a>然后保存。刷新<a href="http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p>
<h2 id="然后，打开终端分别执行如下命令。"><a href="#然后，打开终端分别执行如下命令。" class="headerlink" title="然后，打开终端分别执行如下命令。"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p>
<h2 id="hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片"><a href="#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片" class="headerlink" title="hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href="http://localhost:4000/categories/%E5%9B%BE%E7%89%87">http://localhost:4000/categories/图片</a>, <a href="http://localhost:4000/tags/%E5%9B%BE%E7%89%87">http://localhost:4000/tags/图片</a></h2><h2 id="为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改"><a href="#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改" class="headerlink" title="为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href="http://localhost:4000/">http://localhost:4000</a></p>
<h1 id="5-发布草稿"><a href="#5-发布草稿" class="headerlink" title="5.发布草稿"></a>5.发布草稿</h1><h2 id="如果你暂时还不想要文章被公开访问，可以先创建草稿。如下"><a href="#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下" class="headerlink" title="如果你暂时还不想要文章被公开访问，可以先创建草稿。如下"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href="http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p>
<h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="// 发布草稿"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p>
<h2 id="现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片"><a href="#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片" class="headerlink" title="现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href="http://localhost:4000，便可以看到这篇文章了图片">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id="6-部署博客"><a href="#6-部署博客" class="headerlink" title="6.部署博客"></a>6.部署博客</h1><h2 id="现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。"><a href="#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。" class="headerlink" title="现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href="https://github.com/xxxx/xxxx.github.io.git">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>开发hexo主题记录</title>
    <url>/2023/04/13/%E5%BC%80%E5%8F%91hexo%E4%B8%BB%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="关于-Hexo-及其工作原理"><a href="#关于-Hexo-及其工作原理" class="headerlink" title="关于 Hexo 及其工作原理"></a>关于 Hexo 及其工作原理</h1><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h2><p>Hexo.js 官网的概述是：快速、简洁且高效的博客框架。准确而具体地概述应该是 Hexo.js 是一个基于 Node.js ，可以将 markdown 文件转换为 html 静态界面的博客框架。</p>
<p>换句话说，hexo.js 可以使用 hexo serve 的命令运行提供网站功能，但其最主要的作用应当是生成静态文件，然后交给 nginx / tomcat 等服务器软件进行维护，对外提供网页服务。</p>
<h2 id="Hexo-工作原理"><a href="#Hexo-工作原理" class="headerlink" title="Hexo 工作原理"></a>Hexo 工作原理</h2><p>应该把 Hexo.js 看作一个工具，一个根据配置文件与 markdown 文件以及 html/css/js 代码转换为前端界面的工具。<br>默认情况下 Hexo.js 运行后，将会默认生成多个页面，并具有相应的路径。<br>因此，Hexo 主题的作用就是将每个页面进行特定样式的渲染。</p>
<h2 id="Hexo-快速开始"><a href="#Hexo-快速开始" class="headerlink" title="Hexo 快速开始"></a>Hexo 快速开始</h2><p>按照教程进行初始化项目：<br>hexo init ‘xxxx’<br>cd ‘xxxx’<br>npm install<br>hexo serve<br>访问 4000 端口</p>
<h2 id="总体分析默认的-landscape-主题"><a href="#总体分析默认的-landscape-主题" class="headerlink" title="总体分析默认的 landscape 主题"></a>总体分析默认的 landscape 主题</h2><p>languages 国际化<br>即对于同一个变量对应的语言表达方法，比如 英文 home 简体中文 主页。</p>
<p>layout 主题布局文件<br>在启动 hexo 的时候，博客渲染的入口为其中的 layout.ejs 文件，其他的内容将对应其他 ejs 文件，比如分类对应的是 category.ejs ，标签对应的是 tag.ejs。</p>
<p>这里详细展开 layout 中所有的文件：</p>
<p>_partial: 将整个网页拆成若干个局部模块，这些子模块存储于这个文件夹。<br>_partial/post：查看博客时的所有组件；<br>_partial/post/category.ejs: 查看博客详情时显示博客的类别；<br>_partial/post/date.ejs: 查看博客详情时显示博客的日期；<br>_partial/post/gallery.ejs: 查看博客详情时显示博客的图片；<br>_partial/post/nav.ejs: 查看博客详情时显示博客的上一篇下一篇的导航；<br>_partial/post/tag.ejs: 查看博客详情时显示博客的标签；<br>_partial/post/title.ejs: 查看博客详情时显示博客的标题；<br>_partial/after-footer.ejs：所有页面 html 的最后面应用 js 部分；<br>_partial/archive-post.ejs：对所有博客的归档；<br>_partital/archive.ejs：包括分类，标签以及博客的归档；<br>_partial/article.ejs：展示每篇博客的内容；<br>_partial/footer.ejs：每页内容的最下面展示的内容，比如 copyright 等；<br>_partial/gauges_analytics：对每篇博客的字数统计分析；<br>_partial/google_analytics：对每篇博客的谷歌统计分析；<br>_partial/head.ejs：html 的头部内容；<br>_partial/mobile-nav.ejs：移动端时的导航；<br>_partial/sidebar.ejs：侧边栏；<br>_widget：小工具类，也就是侧边导航栏的组件；<br>_widget/archive.ejs：侧边栏的归档；<br>_widget/category.ejs：侧边栏的分类；<br>_widget/recent_posts.ejs：侧边栏的最近博客；<br>_widget/tag.ejs：侧边栏的标签；<br>_widget/tagcloud.ejs：侧边栏的标签云（使用自带的函数）；<br>archive.ejs ：博客的归档，是直接绑定 archives/ 的入口，根据归档的不同会在这里进行分岔。比如博客的归档，分类的归档，标签的归档。<br>category.ejs：博客的分类，是直接绑定 categories/某类名称 的入口，根据某类名 的不同进行渲染。<br>index.ejs：直接绑定博客的主页，在访问根目录时，对应的 &lt;%- body %&gt; 输出的内容。<br>layout.ejs：整个主题的入口，包括 html 的 <head> 标签等所有内容。一般而言不同页面渲染结果不同是因为 &lt;%- body %&gt; 输出的内容不同。&lt;%-body %&gt; 是自带的内容，会根据访问的是主页还是分类或者标签或者归档进行渲染。<br>page.ejs：特殊页的渲染，除了分类、标签、主页和归档，用户可以自己定义页面，自己定义的页面对应的 markdown 文件的渲染方法与 page.ejs 对应。<br>post.ejs：博客的详细内容渲染，也就是对应 markdown 文件转换出的 html 界面。<br>tag.ejs：标签的分类，直接绑定某个标签的内容，比如访问 tags/某标签 则返回这个标签的所有内容，就是在这里进行控制的。</p>
<p>scripts 主题自带脚本文件夹<br>接下来查看 scripts 文件夹：</p>
<p>fancybox.js：在启动 hexo 时候会运行这个脚本。<br>1.4.4 source 主题自带的资源文件夹<br>主题的渲染过程样式非常重要，主题对应的 css 样式存储于这个文件夹，以及用得到的 js 脚本，也存储于此（与 scripts 不同，那个会启动时自动执行，只执行一次）。</p>
<p>css ：所有的样式文件夹。<br>fancybox：fancybox 对应的样式与 js 文件；<br>js：所有的 js 文件。<br>1.4.5 _config.yml 主题配置文件<br>编写主题的时候必须考虑到不同的人审美、需求是不一样的，为了让用户用起来简单，把尽可能可以通过配置文件配置的内容均放在这个文件中比较合适。比如，主题默认情况下侧边栏的顺序是：<br>widgets:</p>
<ul>
<li>category</li>
<li>tag</li>
<li>archive</li>
</ul>
<h2 id="hexo-主题工作整体流程"><a href="#hexo-主题工作整体流程" class="headerlink" title="hexo 主题工作整体流程"></a>hexo 主题工作整体流程</h2><p>Hexo 启动后，</p>
<ol>
<li>读 scripts 下所有脚本并执行这些脚本；</li>
<li>读取 layout 目录下 layout.ejs 文件；</li>
<li>根据 &lt;%-body%&gt; 在 layout.ejs 的位置进行渲染，包括主页的渲染、分类的渲染、归档的渲染以及自定义页面的渲染。</li>
</ol>
<h1 id="Hexo-主题编写"><a href="#Hexo-主题编写" class="headerlink" title="Hexo 主题编写"></a>Hexo 主题编写</h1><h2 id="新建主题并配置"><a href="#新建主题并配置" class="headerlink" title="新建主题并配置"></a>新建主题并配置</h2><p>在 themes 目录下新建一个文件夹，我们的主题对应的就是这个文件夹，给自己的主题起个名字，我们暂时起名为 wnxx 吧。<br>目前 wnxx 还是为空的文件夹，我们修改根目录的 _config.yml 也就是 Hexo 的配置文件，将主题修改为我们的主题名字 wnxx。<br><img src="/2023/04/13/%E5%BC%80%E5%8F%91hexo%E4%B8%BB%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%B8%BB%E9%A2%98.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>并且在 wnxx 目录下新建 layout 文件夹，并在 layout 下新建 layout.ejs 文件与 index.ejs 文件，前面第一章节介绍过，layout.ejs 是整个主题的入口，而 index.ejs 是必需文件，暂时为空白即可。<br>编辑 layout.ejs 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;wnxx&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    这是入口</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>重启 hexo ，可以看到效果为：<br><img src="/2023/04/13/%E5%BC%80%E5%8F%91hexo%E4%B8%BB%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%A5%E5%8F%A3.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="新建所有功能性文件"><a href="#新建所有功能性文件" class="headerlink" title="新建所有功能性文件"></a>新建所有功能性文件</h2><p>先理清楚所有功能对应的功能性文件，概述一下如表格所示。<br>意博客详情页时默认是 posts/年/月/日/博客标题，也可以自行修改，这里统称为 博客路径。<br>我们根据这个表格新建相应的文件。</p>
<h2 id="熟悉-hexo-内置的变量"><a href="#熟悉-hexo-内置的变量" class="headerlink" title="熟悉 hexo 内置的变量"></a>熟悉 hexo 内置的变量</h2><p>官网文档地址为：中文 <a href="https://hexo.io/zh-cn/docs/variables">https://hexo.io/zh-cn/docs/variables</a> | 英文 <a href="https://hexo.io/docs/variables">https://hexo.io/docs/variables</a> 建议两个都看一下。</p>
<h2 id="layout-ejs"><a href="#layout-ejs" class="headerlink" title="layout.ejs"></a>layout.ejs</h2><p>layout.ejs 是主题的入口，因此整个博客网站不同页面都可以认为是由 layout.ejs “派生” 得到的。换句话说，layout.ejs 中 &lt;%- body %&gt; 具体输出什么是由用户访问的页面决定的，其他部分可以根据具体访问的页面而决定是否展示（比如访问 archive 可以考虑隐藏侧边栏等）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;wnxx&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 网站名 --&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        &lt;a href=&quot;/&quot;&gt;&lt;%= config.title  %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;</span><br><span class="line">        &lt;a href=&quot;&lt;%-url_for(config.archive_dir)%&gt;&quot;&gt;Archive&lt;/a&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;%- body %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;categories&lt;/h3&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;% site.categories.each(category=&gt;&#123; %&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot;&gt;</span><br><span class="line">                    &lt;%- category.name  %&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;tags&lt;/h3&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;% site.tags.each(tag=&gt;&#123; %&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot;&gt;</span><br><span class="line">                    &lt;%- tag.name  %&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="index-ejs"><a href="#index-ejs" class="headerlink" title="index.ejs"></a>index.ejs</h2><p>主页的内容展示带有分页效果的博客，具体的方法与前面的类似，读取 page 变量的所有 posts 然后遍历，渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 主页 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;% page.posts.each(post=&gt;&#123; %&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;&lt;%=url_for(post.path)%&gt;&quot;&gt;</span><br><span class="line">            &lt;%= post.title %&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        | &lt;%- date( post.date , &#x27;YYYY/MM/DD HH:mm&#x27;) %&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;%- paginator(&#123;</span><br><span class="line">    prev_text: &#x27;&lt;&#x27;,</span><br><span class="line">    next_text: &#x27;&gt;&#x27;</span><br><span class="line">&#125;) %&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于npm run xxx的事</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8Enpm%20run%20xxx%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<p>大家在每天开始一天新的工作的时候，第一件事就是打开vs code，然后就在命令行输入npm run start,emmm…之后再等待个一小会，项目就跑起来了，就开始愉快的一天了。<br>那问题来了，你想过npm run xxx之后发生了什么吗？<br>几乎每一个前端项目都一个package.json文件，这个文件里面总是能看到一个关键字 scripts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;,</span><br><span class="line">   &quot;postinstall&quot;: &quot;node ./scripts/postinstall.js&quot;</span><br><span class="line"> &#125;,</span><br><span class="line">  ...,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 npm run xxx 来执行 scripts 中的命令。例如，当我们执行 npm run webpack 时，实际上是在执行 scripts 中的 webpack 命令，即 webpack –config webpack.config.js</p>
<h1 id="一、npm-run-xxx-的时候发生了什么？"><a href="#一、npm-run-xxx-的时候发生了什么？" class="headerlink" title="一、npm  run xxx 的时候发生了什么？"></a>一、npm  run xxx 的时候发生了什么？</h1><p>npm run xxx 的时候，首先会去项目的 package.json 文件里找 scripts 里找对应的 xxx，然后执行 xxx 的命令，例如启动 vue 项目 npm run serve 的时候，实际上就是执行了 vue-cli-service serve 这条命令。<br>package.json 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">  &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="二、那为什么不直接执行vue-cli-service-serve而要执行npm-run-serve-呢？"><a href="#二、那为什么不直接执行vue-cli-service-serve而要执行npm-run-serve-呢？" class="headerlink" title="二、那为什么不直接执行vue-cli-service serve而要执行npm run serve 呢？"></a>二、那为什么不直接执行vue-cli-service serve而要执行npm run serve 呢？</h1><p>因为直接执行vue-cli-service serve，会报错，因为操作系统中没有存在vue-cli-service这一条指令<br>既然vue-cli-service这条指令不存在操作系统中，为什么执行npm run serve的时候，也就是相当于执行了vue-cli-service serve ，为什么这样它就能成功，而且不报指令不存在的错误呢？</p>
<h1 id="三、为什么执行-npm-run-serve-的能成功？"><a href="#三、为什么执行-npm-run-serve-的能成功？" class="headerlink" title="三、为什么执行 npm run serve 的能成功？"></a>三、为什么执行 npm run serve 的能成功？</h1><p>在我们在安装依赖的时候，是通过npm i xxx 来执行的，例如 npm i @vue/cli-service，npm 在 安装这个依赖的时候，就会node_modules/.bin/ 目录中创建 好vue-cli-service 为名的几个可执行文件了。<br>.bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本。<br>当使用 npm run serve 执行 vue-cli-service serve 时，虽然没有安装 vue-cli-service的全局命令，但是 npm 会到 ./node_modules/.bin 中找到vue-cli-service 文件作为脚本来执行。</p>
<h1 id="四、你说-bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？"><a href="#四、你说-bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？" class="headerlink" title="四、你说.bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？"></a>四、你说.bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？</h1><p>从 package-lock.json 中可知，当我们 npm i 整个新建的 vue 项目的时候，npm 将 bin/vue-cli-service.js 作为 bin 声明了<br>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把 node_modules/.bin 加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了<br>假如我们在安装包时，使用  npm install -g xxx  来安装，那么会将其中的 bin 文件加入到全局<br>npm i 的时候，npm 就帮我们把这种软连接配置好了，其实这种软连接相当于一种映射，执行 npm run xxx 的时候，就会到 node_modules/bin 中找对应的映射文件，然后再找到相应的 js 文件来执行。</p>
<h1 id="五、为什么在-node-modules-bin-中-有三个-vue-cli-service-文件？"><a href="#五、为什么在-node-modules-bin-中-有三个-vue-cli-service-文件？" class="headerlink" title="五、为什么在 node_modules/bin 中 有三个 vue-cli-service 文件？"></a>五、为什么在 node_modules/bin 中 有三个 vue-cli-service 文件？</h1><p>如果我们在 cmd 里运行的时候，windows 一般是调用了 vue-cli-service.cmd，这个文件，这是 windows 下的批处理脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ECHO off</span><br><span class="line">GOTO start</span><br><span class="line">:find_dp0</span><br><span class="line">SET dp0=%~dp0</span><br><span class="line">EXIT /b</span><br><span class="line">:start</span><br><span class="line">SETLOCAL</span><br><span class="line">CALL :find_dp0</span><br><span class="line">IF EXIST &quot;%dp0%\node.exe&quot; (</span><br><span class="line">  SET &quot;_prog=%dp0%\node.exe&quot;</span><br><span class="line">) ELSE (</span><br><span class="line">  SET &quot;_prog=node&quot;</span><br><span class="line">  SET PATHEXT=%PATHEXT:;.JS;=;%</span><br><span class="line">)</span><br><span class="line">endLocal &amp; goto #_undefined_# 2&gt;NUL || title %COMSPEC% &amp; &quot;%_prog%&quot;  &quot;%dp0%\..\@vue\cli-service\bin\vue-cli-service.js&quot; %*</span><br></pre></td></tr></table></figure>
<p>所以当我们运行vue-cli-service serve这条命令的时候，就相当于运行 node_modules/.bin/vue-cli-service.cmd serve。<br>然后这个脚本会使用 node 去运行 vue-cli-service.js这个 js 文件<br>由于 node 中可以使用一系列系统相关的 api ，所以在这个 js 中可以做很多事情，例如读取并分析运行这条命令的目录下的文件，根据模板生成文件等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># unix 系默认的可执行文件，必须输入完整文件名</span><br><span class="line">vue-cli-service</span><br><span class="line"># windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件</span><br><span class="line">vue-cli-service.cmd</span><br><span class="line"># Windows PowerShell 中可执行文件，可以跨平台</span><br><span class="line">vue-cli-service.ps1</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>执行npm run xxx时，会先从当前目录下的node_modules/.bin中去查找对应的可执行程序执行；<br>如果无法找到，就会在npm的全局安装路径进行查找，也就是npm i -g xxx时安装的路径；<br>如果还找不到，就会从系统环境变量中查找；<br>再找不到就会报错了；</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端-qiankun</title>
    <url>/2023/03/29/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun/</url>
    <content><![CDATA[<p>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>
<h1 id="qiankun-的核心设计理念"><a href="#qiankun-的核心设计理念" class="headerlink" title="qiankun 的核心设计理念"></a>qiankun 的核心设计理念</h1><ol>
<li>简单<br>由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。</li>
<li>解耦/技术栈无关<br>微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。</li>
</ol>
<h1 id="为什么不是-iframe"><a href="#为什么不是-iframe" class="headerlink" title="为什么不是 iframe"></a>为什么不是 iframe</h1><p>一. 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 “炫技” 或者刻意追求 “特立独行”。<br>如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。<br>二. iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p>
<ol>
<li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li>
<li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li>
<li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li>
<li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。<br>其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。</li>
</ol>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>基于 single-spa 封装，提供了更加开箱即用的 API。</li>
<li>技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。</li>
<li>HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。</li>
<li>样式隔离，确保微应用之间样式互相不干扰。</li>
<li>JS 沙箱，确保微应用之间 全局变量/事件 不冲突。</li>
<li>资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。</li>
<li>umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。</li>
</ol>
<h1 id="快速构建一个qiankun微前端应用"><a href="#快速构建一个qiankun微前端应用" class="headerlink" title="快速构建一个qiankun微前端应用"></a>快速构建一个qiankun微前端应用</h1><h2 id="主应用的配置"><a href="#主应用的配置" class="headerlink" title="主应用的配置"></a>主应用的配置</h2><ol>
<li>首先需要创建一个主应用和至少一个微应用</li>
<li>然后在主应用中安装微前端库：qiankun，yarn add qiankun # 或者 npm i qiankun -S</li>
<li>在主应用的入口处导入qiankun中的两个方法registerMicroApps和start方法</li>
<li>调用registerMicroApps方法注册各个微应用，最后调用start方法来启动qiankun</li>
</ol>
<h2 id="微应用配置"><a href="#微应用配置" class="headerlink" title="微应用配置"></a>微应用配置</h2><ol>
<li>微应用不需要安装qiankun，但必须要在自己的入口处导出三个方法：<br>bootstrap：在微应用启动（初始化）的时候调用一次（只会调用一次）<br>mount：微应用渲染函数，每次微应用进入时都会调用<br>unmount：每次微应用切出或卸载时都会调用</li>
</ol>
<p><strong>注意：</strong>以上三个方法即使不做任何事也必须要导出，否则会报错<br>2. 为了保证每个微应用还能独立运行，还需要在入口处根据全局属性window.__ POWERED_BY_QIANKUN __ 来判断当前应用是由主应用启动还是自己独立运行，从而做出相应的逻辑处理。</p>
<ul>
<li>如果是独立运行则不需额外处理，只是按照原有逻辑进行渲染即可</li>
<li>如果是由主应用启动的，则需将全局变量window.__ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋给变量 __ webpack_public_path __</li>
</ul>
<ol start="3">
<li>如果是webpack等工具构建的应用（如vue或react等）则还需要给微应用的打包工具（webpack）增加一些相应的配置，一般需要配置output的library和libraryTarget。</li>
<li>最后因为不同应用会部署在不同的域下，所以肯定还会有个跨域问题，一般会在服务器端再进行一个允许跨域的配置。</li>
</ol>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="主应用"><a href="#主应用" class="headerlink" title="主应用"></a>主应用</h2><ol>
<li>利用vue脚手架创建一个vue2.0项目：main-app（vue create main-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式。</li>
<li>打开项目main-app，安装qiankun（npm install qiankun –save）</li>
<li>修改App.vue，新增一个subapp的router-link，to值为“/subapp”，并在router-view的下方新增一个id为vueContainer的div盒子（用于承载子应用）。</li>
<li>修改views/Home.vue，将默认内容删除，并改为： This is a home page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>
<li>修改views/About.vue，将内容改为：This is an about page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>
<li>修改main.js，导入qiankun中的registerMicroApps和start两个方法，注册子应用并启动qiankun<br>下面看下修改后的完整代码（创建项目和安装qiankun的步骤就省略了）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">			&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">			&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">			&lt;router-link to=&quot;/subapp&quot;&gt;sub-app&lt;/router-link&gt; &lt;!--新增部分--&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;router-view /&gt;</span><br><span class="line">		&lt;div id=&quot;vueContainer&quot;&gt;&lt;/div&gt;&lt;!--新增部分，用于承载子应用--&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- views/Home.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;home&quot;&gt;This is a home page in qiankun-main&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- views/About.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;home&quot;&gt;This is an about page in qiankun-main&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- main.js --&gt;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">&lt;!-- ======================新增内容开始=============================== --&gt;</span><br><span class="line">import &#123;registerMicroApps, start&#125; from &#x27;qiankun&#x27; //新增部分，导入qiankun中的两个方法</span><br><span class="line">const apps = [</span><br><span class="line">&#123;</span><br><span class="line">	name:&#x27;subApp&#x27;, //子应用的名称</span><br><span class="line">	entry:&#x27;//localhost:8081&#x27;,//子应用的域名</span><br><span class="line">	container:&#x27;#vueContainer&#x27;,//承载子应用的容器，在上面App.vue中定义</span><br><span class="line">	activeRule:&#x27;/subapp&#x27;, // 被激活的子应用的路由</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">registerMicroApps(apps);//注册子应用</span><br><span class="line">start();//启动qiankun</span><br><span class="line">&lt;!-- ======================新增内容结束=============================== --&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">	router,</span><br><span class="line">	render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- router/index.js --&gt;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">import Home from &quot;../views/Home&quot;;</span><br><span class="line">import About from &quot;../views/About&quot;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">const routes = [&#123;</span><br><span class="line">        path: &#x27;/&#x27;,</span><br><span class="line">        name: &#x27;Home&#x27;,</span><br><span class="line">        // redirect: &#x27;/home&#x27;,</span><br><span class="line">        component: Home,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/about&#x27;,</span><br><span class="line">        name: &#x27;About&#x27;,</span><br><span class="line">        component: About,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line">&lt;!-- 以下是修改后的代码 --&gt;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">	mode:&#x27;history&#x27;,</span><br><span class="line">	base: &#x27;&#x27;,</span><br><span class="line">	routes</span><br><span class="line">&#125;)</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="微应用"><a href="#微应用" class="headerlink" title="微应用"></a>微应用</h2><p>微应用中主要需要修改的地方有：main.js、vue.config.js和router/index.js，其余页面部分根据自己喜好可改可不改，本文为了便于区分主子应用的内容将对Home.vue和About.vue页面进行微小的改动</p>
<ol>
<li>利用vue脚手架创建一个vue2.0项目：sub-app（vue create sub-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式</li>
<li>修改views/Home.vue，在原有内容的基础上新增语句：“This is a home page in sub-app”（根据个人喜好，可改可不改）<br>修改views/About.vue，将内容改为：“This is an about page in sub-app”（根据个人喜好，可改可不改）</li>
<li>修改main.js（必需）</li>
</ol>
<ul>
<li>将创建Vue实例的代码部分提取到一个函数render中，render函数接收一个参数props</li>
<li>判断window.__ POWERED_BY_QIANKUN __，如果是从qiankun启动则将window. __ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋值给 __ webpack_public_path __ ，否则直接调用render方法表示子应用是独立运行</li>
<li>导出3个必需的方法bootstrap，mount和unmount；bootstrap函数体内容可为空但函数必须要导出。mount函数中调用render方法进行子应用渲染。unmount函数中将render方法中创建的vue实例销毁。</li>
</ul>
<ol start="4">
<li>修改router/index.js，指定base值为：“/vueChild”</li>
<li>创建vue.config.js，在该文件中配置允许跨域：“ Access-Control-Allow-Origin：’*’ ”，并配置webpack的output.library和output.libraryTarget</li>
</ol>
<p>各部分完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--======================== views/Home.vue ====================--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;home&quot;&gt;</span><br><span class="line">		&lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt;</span><br><span class="line">		&lt;h1 style=&quot;color:red;&quot;&gt;This is a home page in sub-app&lt;/h1&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--======================== views/About.vue ====================--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;About&quot;&gt;		</span><br><span class="line">		This is an about page in sub-app</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--  main.js --&gt;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">let instance = null; //设置全局变量，用于保存或销毁Vue实例</span><br><span class="line">function render(props = &#123;&#125;)&#123;</span><br><span class="line">	const &#123; container &#125; = props</span><br><span class="line">	instance = new Vue(&#123;</span><br><span class="line">		router,</span><br><span class="line">		render: h =&gt; h(App)</span><br><span class="line">	&#125;).$mount(container ? container.querySelector(&quot;#app&quot;) : &quot;#app&quot;);//用于限定当前上下文下的#app，防止与主应用中的#app冲突</span><br><span class="line">&#125;</span><br><span class="line">if(window.__POWERED_BY_QIANKUN__)&#123;</span><br><span class="line">	__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	render();</span><br><span class="line">	console.log(&#x27;子应用独立运行&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">export async function bootstrap(props)&#123;</span><br><span class="line">	console.log(&#x27;这里暂时可以什么都不用做，但方法必须要导出&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">export async function mount(props)&#123;</span><br><span class="line">	render(props);//从qiankun启动</span><br><span class="line">&#125;</span><br><span class="line">export async function unmount(props)&#123;</span><br><span class="line">	instance.$destroy();//销毁子应用实例</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue.config.js --&gt;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	lintOnSave: false,</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		port:8081,</span><br><span class="line">		headers:&#123;</span><br><span class="line">			&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	configureWebpack:&#123;</span><br><span class="line">		output:&#123;</span><br><span class="line">			library:&#x27;subApp&#x27;,</span><br><span class="line">			libraryTarget:&#x27;umd&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- router/index.js --&gt;</span><br><span class="line">// ...原有代码省略</span><br><span class="line">//修改后的代码</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">	mode:&#x27;history&#x27;,</span><br><span class="line">	base:&#x27;/subapp&#x27;,</span><br><span class="line">	routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack迁移vite</title>
    <url>/2023/03/29/webpack%E8%BF%81%E7%A7%BBvite/</url>
    <content><![CDATA[<h1 id="一、迁移流程"><a href="#一、迁移流程" class="headerlink" title="一、迁移流程"></a>一、迁移流程</h1><p>1.先创建新的vite项目<br>2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2<br>3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2<br>4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖<br>5.复制原项目src文件代码和其他业务相关代码到新vite项目。<br>6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。<br>7.在测试开发和打包环境都没问题后，替换原先的项目。</p>
<h1 id="二、迁移业务代码到vite项目"><a href="#二、迁移业务代码到vite项目" class="headerlink" title="二、迁移业务代码到vite项目"></a>二、迁移业务代码到vite项目</h1><h2 id="2-1创建新的vite项目"><a href="#2-1创建新的vite项目" class="headerlink" title="2.1创建新的vite项目"></a>2.1创建新的vite项目</h2><p>由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。<br>npm init vite@latest my-vue-app – –template vue<br>创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖<br>npm i<br>安装依赖完成后，使用npm run dev启动项目<br>此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。</p>
<h2 id="2-2配置vite支持vue2"><a href="#2-2配置vite支持vue2" class="headerlink" title="2.2配置vite支持vue2"></a>2.2配置vite支持vue2</h2><p>此时打开vite.config.js,里面的代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [vue()]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2<br>第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。<br>npm uninstall @vitejs/plugin-vue -D<br>第二步,安装vite-plugin-vue2依赖<br>npm install vite-plugin-vue2 -D<br>第三步,在vite.config.js文件配置vite-plugin-vue2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import &#123; createVuePlugin &#125; from &quot;vite-plugin-vue2&quot;;</span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [createVuePlugin()]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第四步，修改vue版本由3改为2版本<br>npm install vue@2 -S<br>第五步, 修改main.js，创建根vue实例写法改为vue2写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>
<p>第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码<br>执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。</p>
<h2 id="2-3复制原项目业务代码"><a href="#2-3复制原项目业务代码" class="headerlink" title="2.3复制原项目业务代码"></a>2.3复制原项目业务代码</h2><p>第一步，复制原项目静态目录static下文件到vite项目public文件夹下<br>第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type="module" src="/src/main.js"></script><br>第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖<br>第四步，复制原项目src业务文件代码，直接替换vite项目src文件</p>
<h1 id="三、项目开发阶段报错处理"><a href="#三、项目开发阶段报错处理" class="headerlink" title="三、项目开发阶段报错处理"></a>三、项目开发阶段报错处理</h1>]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>打开vite大门</title>
    <url>/2023/04/24/%E6%89%93%E5%BC%80vite%E5%A4%A7%E9%97%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于前端构建工具，先有 gulp、grunt、webpack，现在尤大大又整了一个 vite；<br>或许有同学会疑问，这么多构建工具为什么只有 vite 快，那么我们为什么要使用 vite，以及到底该选哪一个呢？</p>
<h1 id="Vite-简介"><a href="#Vite-简介" class="headerlink" title="Vite 简介"></a>Vite 简介</h1><h2 id="什么是-Vite"><a href="#什么是-Vite" class="headerlink" title="什么是 Vite"></a>什么是 Vite</h2><p>Vite是一个由原生ES Module驱动的Web开发前端构建工具。<br>在开发环境（Development） 下基于浏览器原生 ES Module 开发，完全跳过了打包这个概念；<br>在生产环境（Production） 下基于 Rollup 打包来构建代码。</p>
<h2 id="Vite-的主要特性"><a href="#Vite-的主要特性" class="headerlink" title="Vite 的主要特性"></a>Vite 的主要特性</h2><ul>
<li>💡 极速的服务启动： 使用原生 ESM 文件，无需打包！</li>
<li>⚡️ 轻量快速的热重载： 无论应用程序大小如何，都始终极快的模块热重载（HMR）</li>
<li>🛠️ 丰富的功能： 对 TypeScript、JSX、CSS 等支持开箱即用。</li>
<li>📦 优化的构建：可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建</li>
<li>🔩 通用的插件： 在开发和构建之间共享 Rollup-superset 插件接口。</li>
<li>🔑 完全类型化的API：灵活的 API 和完整 TypeScript 类型<h1 id="Vite-的优势"><a href="#Vite-的优势" class="headerlink" title="Vite 的优势"></a>Vite 的优势</h1></li>
<li>上手非常简单</li>
<li>开发效率极高</li>
<li>社区成本低（兼容绝大部分 rollup 插件）<h2 id="开发效率极高-——-🚀-般的速度"><a href="#开发效率极高-——-🚀-般的速度" class="headerlink" title="开发效率极高 —— 🚀 般的速度"></a>开发效率极高 —— 🚀 般的速度</h2><img src="/2023/04/24/%E6%89%93%E5%BC%80vite%E5%A4%A7%E9%97%A8/vite%E9%80%9F%E5%BA%A6.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>从图中对比我们可以很明显的发现，为什么 Vite 会较于 Webpack 快那么多了<br>Vite 在开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用 esbuild 来进行预构建；（如下图基于原生 ESM 的开发服务流程图）<br><img src="/2023/04/24/%E6%89%93%E5%BC%80vite%E5%A4%A7%E9%97%A8/esm.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>Webpack 在启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码，这可满满都是 CPU、IO 操作啊，在 Node 运行时下性能必然是有问题。（如下图基于 bundle 的开发服务流程图）<br><img src="/2023/04/24/%E6%89%93%E5%BC%80vite%E5%A4%A7%E9%97%A8/bundle.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>当然我们只做了与前端使用率最高，名气最大的 webpack 的对比，像其它构建工具如 Browserify、Gulp、Parcel、Rollup、Snowpack 几乎都是可以类似对比处理。<h2 id="上手极其简单"><a href="#上手极其简单" class="headerlink" title="上手极其简单"></a>上手极其简单</h2>命令初始化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vite2.x 需要 Node.js 版本 &gt;= 12.0.0</span><br><span class="line">Vite3.x 不再支持 Node.js 12，现在需要 Node.js 14.18+</span><br></pre></td></tr></table></figure>
简单一句话概括，如果说你会使用 vue-cli 脚手架，那么这个 Vite 构建工具你几乎可以无缝插入；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # npm</span><br><span class="line"> npm init vite@latest</span><br><span class="line"> ​</span><br><span class="line"> # yarn</span><br><span class="line"> yarn create vite</span><br><span class="line"> ​</span><br><span class="line"> # pnpm</span><br><span class="line"> pnpm create vite</span><br></pre></td></tr></table></figure>
然后按照提示选择你所需要创建的项目即可。<br>配置极其简单<br>相比 webpack（或者底层依赖 Webpack 的 vue-cli）， 需要对 entry、loader、plugin 等进行诸多配置，实际的构建工作通常由各种 webpack loader、plugin 实现；<br>Vite 的使用可谓是相当简单了；只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：css 预处理、html 预处理、异步加载、分包、压缩、HMR支持、默认 chunk hash 命名 等。<br>简单说吧，Vite 的定位就是傻瓜且强大的构建工具。<h2 id="社区成本低"><a href="#社区成本低" class="headerlink" title="社区成本低"></a>社区成本低</h2>除了极致的运行性能与简易的使用方法外，Vite 对已有生态的兼容性也不容忽略，主要体现在<br>两个点：</li>
<li>与 Vue 解耦，兼容支持 React、Svelte、Preact、Vanilla 等，这意味着 Vite 可以被应用在大多数现代技术栈中</li>
<li>与 Rollup 极其接近的插件接口，这意味着可以复用 Rollup 生态中大部分已经被反复锤炼的工具<br>讲真的，这两条摆上桌面，加上前面讨论的 性能优势 和 超低学习成本，你还有什么拒绝的理由呢？<h1 id="Vite-4-3-正式发布，构建速度全面提升"><a href="#Vite-4-3-正式发布，构建速度全面提升" class="headerlink" title="Vite 4.3 正式发布，构建速度全面提升"></a>Vite 4.3 正式发布，构建速度全面提升</h1>最新发布的 Vite 4.3 显著提升了性能。发布公告写道，Vite 团队在这个版本中将工作重心放在提升开发服务器的性能上，其中包括简化解析逻辑、改进热路径、实现更智能的缓存以查找 package.json,TS 配置文件和解析的 URL。  <h1 id="为什么这么快"><a href="#为什么这么快" class="headerlink" title="为什么这么快"></a>为什么这么快</h1><h2 id="更智能的解析策略"><a href="#更智能的解析策略" class="headerlink" title="更智能的解析策略"></a>更智能的解析策略</h2>Vite会将所有接收到的URL和路径解析为目标模块。在 Vite 4.2 中，存在很多冗余的解析逻辑和不必要的模块搜索。为了减少计算和文件系统调用，Vite 4.3 使解析逻辑更简单、更严格和更准确。<h2 id="更简单的解析"><a href="#更简单的解析" class="headerlink" title="更简单的解析"></a>更简单的解析</h2>Vite 4.2严重依赖 resolve 包来解析依赖的 package.json，查看 resolve 的源码发现解析 package.json 时有很多无用的逻辑。Vite 4.3 摒弃了 resolve，遵循更简单的 resolve 逻辑：直接检查嵌套父目录中是否存在 package.json。<h2 id="更严格的解析"><a href="#更严格的解析" class="headerlink" title="更严格的解析"></a>更严格的解析</h2>Vite 必须调用 Nodejs fs API 来查找模块。但是 IO 很昂贵。Vite 4.3 缩小了文件搜索范围，并跳过搜索一些特殊路径，以尽可能减少 fs 调用。例如：</li>
<li>由于 # 符号不会出现在 URL 中，用户可以控制源文件路径中没有 # 符号，因此 Vite 4.3 不再检查用户源文件中带有 # 符号的路径，而是仅在 node_modules 中搜索它们。</li>
<li>在Unix系统中，Vite 4.2 会先检查根目录下的每一个绝对路径，对大多数路径都可以，但是如果绝对路径以根开头就很容易失败。为了在 /root/root 不存在的情况下跳过搜索 /root/root/path-to-file，Vite 4.3 会在开头判断 /root/root 作为目录是否存在，并预先缓存结果。</li>
<li>当 Vite 服务器收到 @fs/xxx​ 和 @vite/xxx 时，就不需要再解析这些 URL。Vite 4.3 直接返回之前缓存的结果，不再重新解析。<h2 id="更准确的解析"><a href="#更准确的解析" class="headerlink" title="更准确的解析"></a>更准确的解析</h2>Vite 4.2 在文件路径为目录时递归解析模块，会导致不必要的重复计算。Vite 4.3 将递归解析扁平化，并对不同类型的路径应用适当的解析，展平后缓存一些 fs 调用也更容易。<h2 id="包解析"><a href="#包解析" class="headerlink" title="包解析"></a>包解析</h2>Vite 4.3 打破了解析 node_modules 包数据的性能瓶颈。Vite 4.2 使用绝对文件路径作为包数据缓存键。这还不够，因为 Vite 必须遍历 pkg/foo/bar​ 和 pkg/foo/baz 中的同一个目录。<br>Vite 4.3 不仅使用了绝对路径(/root/node_modules/pkg/foo/bar.js​ &amp; /root/node_modules/pkg/foo/baz.js​)，还使用了遍历目录(/root/node_modules/pkg/foo​ &amp; /root/node_modules/pkg​) 作为 pkg 缓存的键。<br>另一种情况是，Vite 4.2 在单个函数中查找深层导入路径的 package.json​，例如 Vite 4.2 解析 a/b/c/d​ 等文件路径时，首先检查根 a/package.json​ 是否存在， 如果没有，则按照a/b/c/package.json​ -&gt; a/b/package.json​的顺序查找最近的package.json​，但事实是查找根package.json​和最近的package.json​应该分开处理 ，因为在不同的解析上下文中需要它们。Vite 4.3 将根 package.json​ 和最近的 package.json 解析分成两部分，这样它们就不会混在一起。 <h2 id="fs-realpathSync"><a href="#fs-realpathSync" class="headerlink" title="fs.realpathSync"></a>fs.realpathSync</h2>Nodejs 中有一个有趣的 realpathSync 问题，它指出 fs.realpathSync​ 比 fs.realpathSync.native​ 慢 70 倍。但 Vite 4.2 仅在非 Windows 系统上使用 fs.realpathSync.native​，因为它在 Windows 上的行为不同。为了解决这个问题，Vite 4.3 在 Windows 上调用 fs.realpathSync.native 时添加了网络驱动器验证。<h2 id="非阻塞任务"><a href="#非阻塞任务" class="headerlink" title="非阻塞任务"></a>非阻塞任务</h2>作为一个按需服务，Vite dev server 可以在没有准备好所有东西的情况下启动。<h2 id="非阻塞-tsconfig-解析"><a href="#非阻塞-tsconfig-解析" class="headerlink" title="非阻塞 tsconfig 解析"></a>非阻塞 tsconfig 解析</h2>Vite 服务器在预绑定 ts 或 tsx 时需要 tsconfig 数据。<br>Vite 4.2 在服务端启动之前，在插件钩子 configResolved​ 中等待 tsconfig​ 数据解析完成。一旦服务器启动而没有准备好 tsconfig​ 数据，页面请求就可以访问服务器，即使请求可能需要稍后等待 tsconfig 解析。<br>Vite 4.3 会在服务器启动前初始化 tsconfig​ 解析，但服务器不会等待。解析过程在后台运行。一旦有ts相关的请求进来，就得等tsconfig解析完了。<h2 id="非阻塞文件处理"><a href="#非阻塞文件处理" class="headerlink" title="非阻塞文件处理"></a>非阻塞文件处理</h2>Vite 中有大量的 fs 调用，其中一些是同步的。这些同步 fs 调用可能会阻塞主线程。Vite 4.3 将它们改为异步。此外，并行化异步函数也更容易。关于异步函数，可能有许多 Promise 对象在解析后要释放。由于更智能的解析策略，释放 fs-Promise 对象的成本要低得多。<h2 id="HMR-防抖"><a href="#HMR-防抖" class="headerlink" title="HMR 防抖"></a>HMR 防抖</h2>考虑两个简单的依赖链 C &lt;- B &lt;- A &amp; D &lt;- B &lt;- A，当 A 被编辑时，HMR 将从 A 传播到 C 和 A 传播到 D。这导致 A 和 B 在 Vite 4.2 中被更新两次。<br>Vite 4.3 缓存了这些遍历的模块，以避免多次搜索它们，它适用于由 git checkout 触发的 HMR。<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2>并行化始终是获得更好性能的好选择。在 Vite 4.3 中，我们并行化了一些核心功能，包括导入分析、提取 deps 的导出、解析模块 url 和运行批量优化器。<h2 id="Javascript-优化"><a href="#Javascript-优化" class="headerlink" title="Javascript 优化"></a>Javascript 优化</h2><h2 id="用回调替换-yield"><a href="#用回调替换-yield" class="headerlink" title="用回调替换 *yield"></a>用回调替换 *yield</h2>Vite 使用 tsconfck​ 来查找和解析 tsconfig​ 文件。tsconfck​ 曾经通过 yield​ 遍历目标目录，生成器的一个缺点是它需要更多的内存空间来存储它的生成器对象，并且在运行时会有大量的生成器上下文切换。所以从 v2.1.1 开始在核心中用回调替换 ​​yield​​。</li>
</ul>
<p>3.2 使用 === 代替 startsWith 和 endsWith<br>Vite 4.2 使用 startsWith​ 和 endsWith​ 检查热更新 URL 中的头部和尾部 ‘/‘。比较 str.startsWith(‘x’)​ 和 str[0] === ‘x’​ 的执行基准发现，===​ 比 startsWith​ 快约 20%，endsWith 比 === 慢约 60%。</p>
<h2 id="避免重复创建正则表达式"><a href="#避免重复创建正则表达式" class="headerlink" title="避免重复创建正则表达式"></a>避免重复创建正则表达式</h2><p>Vite 需要很多正则表达式来匹配字符串，其中大部分都是静态的，因此只使用它们的单例会更好。Vite 4.3 将正则表达式提升，以便可以重复使用它们。</p>
<h2 id="放弃生成自定义错误"><a href="#放弃生成自定义错误" class="headerlink" title="放弃生成自定义错误"></a>放弃生成自定义错误</h2><p>在 Vite 4.2 中，有一些自定义错误以改进开发体验。这些错误可能会导致额外的计算和垃圾回收，从而降低 Vite 的速度。在 Vite 4.3 中，放弃了生成某些热更新自定义错误（例如 package.json NOT_FOUND 错误），直接抛出原始错误以获得更好的性能。</p>
]]></content>
      <categories>
        <category>vite</category>
      </categories>
      <tags>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化</title>
    <url>/2023/04/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h1><h2 id="1-1、-v-if-和-v-show-区分使用场景"><a href="#1-1、-v-if-和-v-show-区分使用场景" class="headerlink" title="1.1、 v-if 和 v-show 区分使用场景"></a>1.1、 v-if 和 v-show 区分使用场景</h2><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h2 id="1-2、computed-和-watch-区分使用场景"><a href="#1-2、computed-和-watch-区分使用场景" class="headerlink" title="1.2、computed 和 watch 区分使用场景"></a>1.2、computed 和 watch 区分使用场景</h2><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h2 id="1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v"><a href="#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v" class="headerlink" title="1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-</h2><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。<br>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。<br>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;user in activeUsers&quot;</span><br><span class="line">    :key=&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: function () &#123;</span><br><span class="line">    return this.users.filter(function (user) &#123;</span><br><span class="line">	 return user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;user in users&quot;</span><br><span class="line">    v-if=&quot;user.isActive&quot;</span><br><span class="line">    :key=&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-4、长列表性能优化"><a href="#1-4、长列表性能优化" class="headerlink" title="1.4、长列表性能优化"></a>1.4、长列表性能优化</h2><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: () =&gt; (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  async created() &#123;</span><br><span class="line">    const users = await axios.get(&quot;/api/users&quot;);</span><br><span class="line">    this.users = Object.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5、事件的销毁"><a href="#1-5、事件的销毁" class="headerlink" title="1.5、事件的销毁"></a>1.5、事件的销毁</h2><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6、图片资源懒加载"><a href="#1-6、图片资源懒加载" class="headerlink" title="1.6、图片资源懒加载"></a>1.6、图片资源懒加载</h2><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：<br>（1）安装插件<br>npm install vue-lazyload –save-dev<br>（2）在入口文件 man.js 中引入并使用<br>import VueLazyload from ‘vue-lazyload’<br>然后再 vue 中直接使用<br>Vue.use(VueLazyload)<br>或者添加自定义选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  error: &#x27;dist/error.png&#x27;,</span><br><span class="line">  loading: &#x27;dist/loading.gif&#x27;,</span><br><span class="line">  attempt: 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-7、路由懒加载"><a href="#1-7、路由懒加载" class="headerlink" title="1.7、路由懒加载"></a>1.7、路由懒加载</h2><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br>路由懒加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Foo = () =&gt; import(&#x27;./Foo.vue&#x27;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;/foo&#x27;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1-8、第三方插件的按需引入"><a href="#1-8、第三方插件的按需引入" class="headerlink" title="1.8、第三方插件的按需引入"></a>1.8、第三方插件的按需引入</h2><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>（1）首先，安装 babel-plugin-component ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<p>（2）然后，将 .babelrc 修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在 main.js 中引入部分组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure>

<h2 id="1-9、优化无限列表性能"><a href="#1-9、优化无限列表性能" class="headerlink" title="1.9、优化无限列表性能"></a>1.9、优化无限列表性能</h2><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。</p>
<h2 id="1-10、服务端渲染-SSR-or-预渲染"><a href="#1-10、服务端渲染-SSR-or-预渲染" class="headerlink" title="1.10、服务端渲染 SSR or 预渲染"></a>1.10、服务端渲染 SSR or 预渲染</h2><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。<br>（1）服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；<br>（2）服务端渲染的缺点：</li>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。<br>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</li>
</ul>
<h1 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h1><h2 id="2-1、Webpack-对图片进行压缩"><a href="#2-1、Webpack-对图片进行压缩" class="headerlink" title="2.1、Webpack 对图片进行压缩"></a>2.1、Webpack 对图片进行压缩</h2><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader 来压缩图片：<br>（1）首先，安装 image-webpack-loader ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /.(png|jpe?g|gif|svg)(?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000,</span><br><span class="line">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、减少-ES6-转为-ES5-的冗余代码"><a href="#2-2、减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="2.2、减少 ES6 转为 ES5 的冗余代码"></a>2.2、减少 ES6 转为 ES5 的冗余代码</h2><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HelloWebpack extends Component&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">babel-runtime/helpers/createClass  // 用于实现 class 语法</span><br><span class="line">babel-runtime/helpers/inherits  // 用于实现 extends 语法</span><br></pre></td></tr></table></figure>

<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。<br>（1）首先，安装 babel-plugin-transform-runtime ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）然后，修改 .babelrc 配置文件为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看 babel-plugin-transform-runtime 的详细介绍。</p>
<h2 id="2-3、提取公共代码"><a href="#2-3、提取公共代码" class="headerlink" title="2.3、提取公共代码"></a>2.3、提取公共代码</h2><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<ul>
<li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li>
<li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个 Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#x27;vendor&#x27;,</span><br><span class="line">  minChunks: function(module, count) &#123;</span><br><span class="line">    return (</span><br><span class="line">      module.resource &amp;&amp;</span><br><span class="line">      /.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">      module.resource.indexOf(</span><br><span class="line">        path.join(__dirname, &#x27;../node_modules&#x27;)</span><br><span class="line">      ) === 0</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">// 抽取出代码模块的映射关系</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#x27;manifest&#x27;,</span><br><span class="line">  chunks: [&#x27;vendor&#x27;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的详细介绍。</p>
<h2 id="2-4、模板预编译"><a href="#2-4、模板预编译" class="headerlink" title="2.4、模板预编译"></a>2.4、模板预编译</h2><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<h2 id="2-5、提取组件的-CSS"><a href="#2-5、提取组件的-CSS" class="headerlink" title="2.5、提取组件的 CSS"></a>2.5、提取组件的 CSS</h2><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。<br>查阅这个构建工具各自的文档来了解更多：<br>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)<br>Browserify + vueify<br>Rollup + rollup-plugin-vue</p>
<h2 id="2-6、优化-SourceMap"><a href="#2-6、优化-SourceMap" class="headerlink" title="2.6、优化 SourceMap"></a>2.6、优化 SourceMap</h2><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel 编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug 的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。<br>开发环境推荐： cheap-module-eval-source-map<br>生产环境推荐： cheap-module-source-map<br>原因如下：</p>
<ul>
<li>cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</li>
<li>module ：不管是开发环境还是正式环境，我们都希望能定位到 bug 的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</li>
<li>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加 source-map 属性；</li>
<li>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</li>
</ul>
<h2 id="2-7、构建结果输出分析"><a href="#2-7、构建结果输出分析" class="headerlink" title="2.7、构建结果输出分析"></a>2.7、构建结果输出分析</h2><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。<br>我们在项目中 webpack.prod.conf.js 进行配置：<br>if (config.build.bundleAnalyzerReport) { var BundleAnalyzerPlugin = require(‘webpack-bundle-analyzer’).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin()); }</p>
<h2 id="2-8、Vue-项目的编译优化"><a href="#2-8、Vue-项目的编译优化" class="headerlink" title="2.8、Vue 项目的编译优化"></a>2.8、Vue 项目的编译优化</h2><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</p>
<p>[<a href="https://micro-frontends.org/]">https://micro-frontends.org/]</a></p>
<p>[<a href="https://martinfowler.com/articles/micro-frontends.html]">https://martinfowler.com/articles/micro-frontends.html]</a></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端</title>
    <url>/2023/03/27/%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h1><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。<br>微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。</p>
<h1 id="微前端架构具备以下几个核心价值："><a href="#微前端架构具备以下几个核心价值：" class="headerlink" title="微前端架构具备以下几个核心价值："></a>微前端架构具备以下几个核心价值：</h1><ol>
<li>技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权</li>
<li>独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>
<li>增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</li>
<li>独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</li>
</ol>
<h1 id="常见的微前端实现方式"><a href="#常见的微前端实现方式" class="headerlink" title="常见的微前端实现方式"></a>常见的微前端实现方式</h1><h2 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h2><p>简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。<br>例如：<br>使用 Nginx 代理了 <code>localhost:80</code>；<br>然后访问路径为 /app1 的时候，返回<code>html/app1/index.html</code>的文件；<br>访问路径为 /app2 的时候，返回 <code>html/app2/index.html</code> 的文件。<br>这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>开发成本低<br>配置简单</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）<br>多应用间不能共享数据<br>多应用间通信困难<br>多应用公共依赖重复加载</p>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。<br>但实际上个大微前端框架，就没有一个是用 iframe 去做的，因为 iframe 有着很多的问题，其中一些甚至是无法解决的。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>完美支持 js 隔离，样式隔离</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>url 不同步， 浏览器刷新时，iframe 中的 url 状态会丢失<br>iframe 局部弹框<br>内外通信效率低下，变量不能共享<br>每次进入，资源都会被重新加载，速度较慢</p>
<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><p>Web Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。<br>(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br>(2)Shadow DOM（影子 DOM） ：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。<br>(3)HTML templates（HTML 模板）：<code> &lt;template&gt; </code> 和  <code>&lt;slot&gt; </code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</p>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>每个服务拥有独立的脚本和样式</p>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>改造成本大<br>各个浏览器兼容不友好<br>多应用公共依赖重复加载</p>
<h2 id="single-SPA"><a href="#single-SPA" class="headerlink" title="single-SPA"></a>single-SPA</h2><p>single-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。</p>
<h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><p>良好的体验，多服务切换如同单体 SPA<br>具备服务的生命周期<br>共享数据<br>兼容不同技术栈运行</p>
<h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>多应用间，无多应用沙箱机制<br>多应用间，样式命名不慎会导致冲突<br>js entry 导致子服务和基座强耦合</p>
<h2 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h2><p>乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是 start 最多的。<br>其代码写的很漂亮，建议大家去阅读，学习。</p>
<h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><p>基于 single-SPA 封装，开箱即用<br>技术无关，多技术栈可以共存<br>html entry 接入，解耦基座和子服务<br>样式隔离<br>js 沙箱机制<br>资源预加载<br>提供全局错误机制<br>提供跨服务通信机制<br>提供服务的生命周期<br>脱离基座，单个服务降级运行策略处理</p>
<h2 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h2><p>共享运行时缓存支持<br>不兼容 ie 系列</p>
<h1 id="现有市面框架"><a href="#现有市面框架" class="headerlink" title="现有市面框架"></a>现有市面框架</h1><ol>
<li>single-spa 将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架</li>
<li>qiankun 蚂蚁金服，在 single-spa 的基础上封装</li>
<li>MicroApp 京东，一款基于 WebComponent 的思想，轻量、高效、功能强大的微前端框架 4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱</li>
<li>EMP YY 语音，基于 Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力</li>
<li>icestark 阿里出品，是一个面向大型系统的微前端解决方案</li>
<li>garfish 字节跳动</li>
<li>magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数</li>
</ol>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。<br>更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：<br>Micro Frontends(<a href="https://micro-frontends.org/">https://micro-frontends.org/</a>)<br>Micro Frontends from martinfowler.com(<a href="https://martinfowler.com/articles/micro-frontends.html">https://martinfowler.com/articles/micro-frontends.html</a>)</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数组，对象遍历的用法总结</title>
    <url>/2023/03/21/%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p>
<h1 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h1><h2 id="方法一：for循环"><a href="#方法一：for循环" class="headerlink" title="方法一：for循环"></a>方法一：for循环</h2><h3 id="for-循环是使用最多，也是性能优化最好的一种遍历方式。"><a href="#for-循环是使用最多，也是性能优化最好的一种遍历方式。" class="headerlink" title="for 循环是使用最多，也是性能优化最好的一种遍历方式。"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">// Expected output:a b c</span><br></pre></td></tr></table></figure>
<h2 id="方法二：for-of-遍历"><a href="#方法二：for-of-遍历" class="headerlink" title="方法二：for-of 遍历"></a>方法二：for-of 遍历</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">for (let item of arr) &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br><span class="line">// Expected output:a b c</span><br></pre></td></tr></table></figure>
<h2 id="方法三：数组方法"><a href="#方法三：数组方法" class="headerlink" title="方法三：数组方法"></a>方法三：数组方法</h2><h3 id="1-forEach-方法，对原数组没有影响"><a href="#1-forEach-方法，对原数组没有影响" class="headerlink" title="1.forEach()方法，对原数组没有影响"></a>1.forEach()方法，对原数组没有影响</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">arr.forEach((index, item) =&gt; &#123;</span><br><span class="line">  console.log(index, item)</span><br><span class="line">&#125;)</span><br><span class="line">//Expected output:</span><br><span class="line">// a 0</span><br><span class="line">// b 1</span><br><span class="line">// c 2</span><br></pre></td></tr></table></figure>
<h3 id="2-map-方法"><a href="#2-map-方法" class="headerlink" title="2.map()方法"></a>2.map()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var newArr = arr.map(item =&gt; &#123;</span><br><span class="line">  return item * 2</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArr); </span><br><span class="line">// Expected output:[2, 4, 6]</span><br></pre></td></tr></table></figure>
<h3 id="3-filter-方法，不改变原始数组"><a href="#3-filter-方法，不改变原始数组" class="headerlink" title="3.filter()方法，不改变原始数组"></a>3.filter()方法，不改变原始数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var newArr = arr.filter(item =&gt; &#123;</span><br><span class="line">  return item &gt; 1</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArr)</span><br><span class="line">// Expected output:[2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="4-reduce-方法"><a href="#4-reduce-方法" class="headerlink" title="4.reduce()方法"></a>4.reduce()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var sum = arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">  return pre + cur</span><br><span class="line">&#125;);</span><br><span class="line">console.log(sum)</span><br><span class="line">// Expected output:6</span><br></pre></td></tr></table></figure>
<h3 id="5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。"><a href="#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。" class="headerlink" title="5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var bool = arr.every(item =&gt; &#123;</span><br><span class="line">  return item &lt; 5</span><br><span class="line">&#125;);</span><br><span class="line">console.log(bool)</span><br><span class="line">// Expected output:true</span><br></pre></td></tr></table></figure>
<h3 id="6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。"><a href="#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。" class="headerlink" title="6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id="下面的例子是检测数组元素是否存在-Number-类型。"><a href="#下面的例子是检测数组元素是否存在-Number-类型。" class="headerlink" title="下面的例子是检测数组元素是否存在 Number 类型。"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, 1, &quot;b&quot;]</span><br><span class="line">var bool = arr.some(item =&gt; &#123;</span><br><span class="line">  return typeof item === &quot;number&quot;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(bool)</span><br><span class="line">// Expected output:true</span><br></pre></td></tr></table></figure>
<h3 id="7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。"><a href="#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。" class="headerlink" title="7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">let find = arr.find((item) =&gt; &#123;</span><br><span class="line">  return item % 2 === 0</span><br><span class="line">&#125;)</span><br><span class="line">// Expected output:find =2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var ret = arr.find(ele =&gt; ele &gt; 2)</span><br><span class="line">console.log(ret)</span><br><span class="line">// Expected output:3</span><br><span class="line">console.log(arr)</span><br><span class="line">// Expected output:[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。"><a href="#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。" class="headerlink" title="8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">let findIndex = arr.findIndex((item) =&gt; &#123;</span><br><span class="line">  return item % 2 === 0</span><br><span class="line">&#125;) </span><br><span class="line">// Expected output:findIndex = 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4 ,5]</span><br><span class="line">var ret = arr.findIndex(ele =&gt; ele &gt; 2) </span><br><span class="line">console.log(ret)</span><br><span class="line">// Expected output:2</span><br><span class="line"> console.log(arr)</span><br><span class="line">// Expected output:[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h1 id="二、遍历对象"><a href="#二、遍历对象" class="headerlink" title="二、遍历对象"></a>二、遍历对象</h1><h2 id="方法一：for-in-循环"><a href="#方法一：for-in-循环" class="headerlink" title="方法一：for-in 循环"></a>方法一：for-in 循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; a: 2, b: 4, c: 6 &#125;</span><br><span class="line">for (let key in obj) &#123;</span><br><span class="line">  console.log(key)</span><br><span class="line">&#125;</span><br><span class="line">// Expected output:a b c</span><br></pre></td></tr></table></figure>
<h2 id="方法二：Object-keys-可理解为返回里面的key属性"><a href="#方法二：Object-keys-可理解为返回里面的key属性" class="headerlink" title="方法二：Object.keys() 可理解为返回里面的key属性"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id="1-处理对象时：返回可枚举的属性数组"><a href="#1-处理对象时：返回可枚举的属性数组" class="headerlink" title="1.处理对象时：返回可枚举的属性数组"></a>1.处理对象时：返回可枚举的属性数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.keys(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[&#x27;name&#x27;, &#x27;address&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="2-处理数组时：返回索引值数组"><a href="#2-处理数组时：返回索引值数组" class="headerlink" title="2.处理数组时：返回索引值数组"></a>2.处理数组时：返回索引值数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.keys([11,22,33,44]) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="3-处理字符串数据时：返回索引值数组"><a href="#3-处理字符串数据时：返回索引值数组" class="headerlink" title="3.处理字符串数据时：返回索引值数组"></a>3.处理字符串数据时：返回索引值数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str=&#x27;hello&#x27;;</span><br><span class="line">console.log(Object.keys(str))</span><br><span class="line">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。"><a href="#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。" class="headerlink" title="方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id="1-处理对象数据时：返回可枚举的值组成的数组"><a href="#1-处理对象数据时：返回可枚举的值组成的数组" class="headerlink" title="1.处理对象数据时：返回可枚举的值组成的数组"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.values(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[&#x27;wn&#x27;, &#x27;中国&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="2-处理数组数据时：返回原数组"><a href="#2-处理数组数据时：返回原数组" class="headerlink" title="2.处理数组数据时：返回原数组"></a>2.处理数组数据时：返回原数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.values([11,22,33,44]) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[11,22,33,44]</span><br></pre></td></tr></table></figure>
<h3 id="属性名为数值的属性，是按照数值大小，从小到大遍历的。"><a href="#属性名为数值的属性，是按照数值大小，从小到大遍历的。" class="headerlink" title="属性名为数值的属性，是按照数值大小，从小到大遍历的。"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;10 : &quot;a&quot;, 6 : &quot;b&quot;, 9 : &quot;c&quot;&#125;</span><br><span class="line">console.log(Object.values(obj))</span><br><span class="line">// Expected output:[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="3-处理字符串数据时：返回每个字符组成的数组"><a href="#3-处理字符串数据时：返回每个字符组成的数组" class="headerlink" title="3.处理字符串数据时：返回每个字符组成的数组"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.values(&#x27;hello&#x27;))</span><br><span class="line">// Expected output:[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="4-Object-values会过滤属性名为-Symbol-值的属性"><a href="#4-Object-values会过滤属性名为-Symbol-值的属性" class="headerlink" title="4.Object.values会过滤属性名为 Symbol 值的属性"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.values(&#123; [Symbol()]: 123, foo: &#x27;abc&#x27; &#125;)</span><br><span class="line">// Expected output:[&#x27;abc&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="方法四：Object-entries-方法"><a href="#方法四：Object-entries-方法" class="headerlink" title="方法四：Object.entries()方法"></a>方法四：Object.entries()方法</h2><h3 id="1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。"><a href="#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。" class="headerlink" title="1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.entries(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[[&#x27;name&#x27;, &#x27;wn&#x27;], [&#x27;address&#x27;, &#x27;中国&#x27;]]</span><br></pre></td></tr></table></figure>
<h3 id="2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。"><a href="#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。" class="headerlink" title="2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.entries([11,22,33,44]) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[ [&#x27;0&#x27;,11], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>
<h3 id="数组中包含对象："><a href="#数组中包含对象：" class="headerlink" title="数组中包含对象："></a>数组中包含对象：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w_n = Object.entries([&#123;a:11&#125;,22,33,44]) </span><br><span class="line">console.log(w_n)</span><br><span class="line">// Expected output:[ [&#x27;0&#x27;,&#123;a:11&#125;], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>
<h3 id="3-处理字符串数据时：返回也是一个二维数组。"><a href="#3-处理字符串数据时：返回也是一个二维数组。" class="headerlink" title="3.处理字符串数据时：返回也是一个二维数组。"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str=&#x27;hello&#x27;</span><br><span class="line">console.log(Object.entries(str)) </span><br><span class="line">// Expected output:[ [&#x27;0&#x27;,&#x27;h&#x27;], [&#x27;1&#x27;,&#x27;e&#x27;], [&#x27;2&#x27;,&#x27;l&#x27;], [&#x27;3&#x27;,&#x27;l&#x27;] ,[&#x27;4&#x27;,&#x27;o&#x27;] ]</span><br></pre></td></tr></table></figure>
<h2 id="方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。"><a href="#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。" class="headerlink" title="方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id="注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"><a href="#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。" class="headerlink" title="注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">const source = &#123; b: 4, c: 5 &#125;;</span><br><span class="line">const returnedTarget = Object.assign(target, source);</span><br><span class="line">console.log(target);</span><br><span class="line">// Expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法六：Object-getOwnPropertyNames"><a href="#方法六：Object-getOwnPropertyNames" class="headerlink" title="方法六：Object.getOwnPropertyNames()"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id="Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。"><a href="#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。" class="headerlink" title="Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(arr).sort()) </span><br><span class="line">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="// 类数组对象"></a>// 类数组对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).sort())</span><br><span class="line">// Expected output:[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="使用-Array-forEach-输出属性名和属性值"><a href="#使用-Array-forEach-输出属性名和属性值" class="headerlink" title="// 使用 Array.forEach 输出属性名和属性值"></a>// 使用 Array.forEach 输出属性名和属性值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) &#123;</span><br><span class="line">  console.log(val + &quot; -&gt; &quot; + obj[val])</span><br><span class="line">&#125;)</span><br><span class="line">// Expected output:</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br></pre></td></tr></table></figure>
<h3 id="不可枚举属性"><a href="#不可枚举属性" class="headerlink" title="//不可枚举属性"></a>//不可枚举属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">    value: function() &#123; return this.foo; &#125;,</span><br><span class="line">    enumerable: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">my_obj.foo = 1</span><br><span class="line">console.log(Object.getOwnPropertyNames(my_obj).sort())</span><br><span class="line">// Expected output:[&quot;foo&quot;, &quot;getFoo&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化(一)</title>
    <url>/2023/04/11/%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。</p>
<h1 id="模块化简述"><a href="#模块化简述" class="headerlink" title="模块化简述"></a>模块化简述</h1><p>把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现。</p>
<h1 id="模块化的诞生"><a href="#模块化的诞生" class="headerlink" title="模块化的诞生"></a>模块化的诞生</h1><p>简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体。<br>前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化。</p>
<h1 id="模块化的演进"><a href="#模块化的演进" class="headerlink" title="模块化的演进"></a>模块化的演进</h1><h2 id="第一阶段：仅仅基于文件的划分模块的方式"><a href="#第一阶段：仅仅基于文件的划分模块的方式" class="headerlink" title="第一阶段：仅仅基于文件的划分模块的方式"></a>第一阶段：仅仅基于文件的划分模块的方式</h2><p>具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）。<br>缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系。</p>
<h2 id="第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中"><a href="#第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中" class="headerlink" title="第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中"></a>第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中</h2><p>具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。<br>通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。</p>
<h2 id="第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked-Function-Expression）为模块提供私有空间"><a href="#第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked-Function-Expression）为模块提供私有空间" class="headerlink" title="第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间"></a>第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间</h2><p>具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现。<br>有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。</p>
<h2 id="第四阶段：-利用-IIFE-参数作为依赖声明使用"><a href="#第四阶段：-利用-IIFE-参数作为依赖声明使用" class="headerlink" title="第四阶段： 利用 IIFE 参数作为依赖声明使用"></a>第四阶段： 利用 IIFE 参数作为依赖声明使用</h2><p>具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。<br>这使得每一个模块之间的关系变得更加明显。</p>
<h2 id="第五阶段：-模块化规范"><a href="#第五阶段：-模块化规范" class="headerlink" title="第五阶段： 模块化规范"></a>第五阶段： 模块化规范</h2><p>Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器—模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。</p>
<h1 id="模块化规范的出现"><a href="#模块化规范的出现" class="headerlink" title="模块化规范的出现"></a>模块化规范的出现</h1><p>需：模块化标准+模块加载器</p>
<h2 id="CommonJS规范-nodejs提出的一套标准"><a href="#CommonJS规范-nodejs提出的一套标准" class="headerlink" title="CommonJS规范(nodejs提出的一套标准)"></a>CommonJS规范(nodejs提出的一套标准)</h2><ul>
<li>标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块。</li>
<li>缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低。<h2 id="AMD-Asynchronous-Module-Definition-—-异步模块定义规范"><a href="#AMD-Asynchronous-Module-Definition-—-异步模块定义规范" class="headerlink" title="AMD(Asynchronous Module Definition) — 异步模块定义规范"></a>AMD(Asynchronous Module Definition) — 异步模块定义规范</h2>模块通过define函数定义</li>
<li>优势：目前绝大多数第三方库都支持AMD规范</li>
<li>缺点： 使用复杂模块划分细致，模块JS文件会出现请求频繁的情况<h2 id="Sea-js-淘宝推出-CMD-通用模块定义规范"><a href="#Sea-js-淘宝推出-CMD-通用模块定义规范" class="headerlink" title="Sea.js(淘宝推出) + CMD(通用模块定义规范)"></a>Sea.js(淘宝推出) + CMD(通用模块定义规范)</h2>CMD规范类似CommonJS规范 后期也被Require.js兼容了<h2 id="Require-js"><a href="#Require-js" class="headerlink" title="Require.js"></a>Require.js</h2>提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块<h1 id="模块化默认规范"><a href="#模块化默认规范" class="headerlink" title="模块化默认规范"></a>模块化默认规范</h1>浏览器环境使用ES Modules<br>nodejs使用CommonJS<h1 id="关于ES-Modules"><a href="#关于ES-Modules" class="headerlink" title="关于ES Modules"></a>关于ES Modules</h1>通过给 script 添加 type = module 的属性使用 ES Modules</li>
<li>ESM 自动采用严格模式，忽略 ‘use strict’</li>
<li>每个 ES Module 都是运行在单独的私有作用域中</li>
<li>ESM 是通过 CORS 的方式请求外部 JS 模块的</li>
<li>ESM 的 script 标签会延迟执行脚本<br>对于我们前端平时开发，其实用得最多的是es modules，这里也简单介绍一下这种规范的一些常用写法<h2 id="ES-Modules-导出"><a href="#ES-Modules-导出" class="headerlink" title="ES Modules 导出"></a>ES Modules 导出</h2>单个导出<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const name = &#x27;foo module&#x27;</span><br><span class="line">export function hello () &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
合并导出<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;foo module&#x27;</span><br><span class="line">function hello () &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line">export &#123; name, hello, Person &#125;</span><br></pre></td></tr></table></figure>
合并导出，且重命名<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;foo module&#x27;</span><br><span class="line">function hello () &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line">export &#123;</span><br><span class="line">    name1: name,</span><br><span class="line">    hello2: hello,</span><br><span class="line">    Person3: Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
默认导出<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;foo module&#x27;</span><br><span class="line">function hello () &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line">export default name;</span><br></pre></td></tr></table></figure>
<h2 id="ES-Modules-导入导出的注意事项"><a href="#ES-Modules-导入导出的注意事项" class="headerlink" title="ES Modules 导入导出的注意事项"></a>ES Modules 导入导出的注意事项</h2>导出字面量和导出模块的区别<br>导出字面量(如:对象):export default { name, age }<br>注意: import {name, age} from ‘modulename’导入模块无法使用到name和age的值<br>导出模块:<br>export { name, age }<br>import {name, age} from ‘modulename’ 导入模块可以使用到name和age的值<br>原因：import导入的是对模块内部的使用<h3 id="导出模块的引用"><a href="#导出模块的引用" class="headerlink" title="导出模块的引用"></a>导出模块的引用</h3>注意：export暴露的是模块的引用关系(地址)，并且只读不可修改(尝试修改会报错误—Uncaught TypeError:Assignment to constant variable)<br>注意点</li>
<li>CommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员 const { name, age } = require(‘./module.js’)</li>
<li>ES Module 中 { } 是固定语法，就是直接提取模块导出成员 import { name, age } from ‘./module.js’</li>
<li>导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改</li>
<li>导入模块成员变量是只读的 name = ‘tom’ // 报错</li>
<li>导入的是一个对象，对象的属性读写不受影响 name.xxx = ‘xxx’ // 正常</li>
</ul>
<h2 id="ES-Modules-导入"><a href="#ES-Modules-导入" class="headerlink" title="ES Modules 导入"></a>ES Modules 导入</h2><h3 id="导入文件路径"><a href="#导入文件路径" class="headerlink" title="导入文件路径"></a>导入文件路径</h3><p>需要引用的名称<br>相对路径上的./不能省略<br>可以使用绝对路径和完整的url</p>
<h3 id="导入模块时是否提取模块成员"><a href="#导入模块时是否提取模块成员" class="headerlink" title="导入模块时是否提取模块成员"></a>导入模块时是否提取模块成员</h3><p>导入模块并提取模块成员 import {} from ‘./module.js’<br>导入模块暂不提取模块成员 import ‘./module.js’ (导入不需要外界控制的子功能模块时很有用)</p>
<h3 id="同时导入模块多个成员或所有成员"><a href="#同时导入模块多个成员或所有成员" class="headerlink" title="同时导入模块多个成员或所有成员"></a>同时导入模块多个成员或所有成员</h3><p>import * as mod from ‘./module.js’ 需要把所有提取成员放到一个对象当中，通过as,导入的成员都会作为对象属性出现</p>
<h3 id="动态导入模块-在需要满足某些条件才能导入时可用"><a href="#动态导入模块-在需要满足某些条件才能导入时可用" class="headerlink" title="动态导入模块(在需要满足某些条件才能导入时可用)"></a>动态导入模块(在需要满足某些条件才能导入时可用)</h3><p>import (‘./module.js’) 返回的是promise 取模块成员的方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import(&#x27;./module.js&#x27;).then(function (module) &#123;</span><br><span class="line">    //所有模块成员都在module参数里</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="同时导入命名成员和默认成员"><a href="#同时导入命名成员和默认成员" class="headerlink" title="同时导入命名成员和默认成员"></a>同时导入命名成员和默认成员</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; name, age, default as other&#125; from &#x27;./module.js&#x27; </span><br><span class="line">或者</span><br><span class="line">import other,&#123; name, age&#125; from &#x27;./module.js&#x27;other   代表module模块所有默认导出的成员</span><br></pre></td></tr></table></figure>
<h2 id="ES-Modules-in-Node-js"><a href="#ES-Modules-in-Node-js" class="headerlink" title="ES Modules in Node.js"></a>ES Modules in Node.js</h2><p>ES Modules in Node.js - 与 CommonJS 交互<br>ES Module 中可以导入 CommonJS 模块</p>
<h3 id="es-module-mjs"><a href="#es-module-mjs" class="headerlink" title="es-module.mjs"></a>es-module.mjs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import mod from &#x27;./commonjs.js&#x27;</span><br><span class="line">console.log(mod)</span><br></pre></td></tr></table></figure>
<p>不能直接提取成员，注意 import 不是解构导出对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; foo &#125; from &#x27;./commonjs.js&#x27;</span><br><span class="line">console.log(foo)</span><br><span class="line">export const foo = &#x27;es module export value&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="CommonJS-模块始终只会导出一个默认成员"><a href="#CommonJS-模块始终只会导出一个默认成员" class="headerlink" title="CommonJS 模块始终只会导出一个默认成员"></a>CommonJS 模块始终只会导出一个默认成员</h3><p>commonjs.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    foo: &#x27;commonjs exports value&#x27;</span><br><span class="line">&#125;</span><br><span class="line">exports.foo = &#x27;commonjs exports value&#x27;</span><br></pre></td></tr></table></figure>
<p>不能在 CommonJS 模块中通过 require 载入 ES Module</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mod = require(&#x27;./es-module.mjs&#x27;)</span><br><span class="line">console.log(mod)</span><br></pre></td></tr></table></figure>
<h2 id="ES-Modules-in-Node-js-与-CommonJS-的差异"><a href="#ES-Modules-in-Node-js-与-CommonJS-的差异" class="headerlink" title="ES Modules in Node.js - 与 CommonJS 的差异"></a>ES Modules in Node.js - 与 CommonJS 的差异</h2><p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 加载模块函数</span><br><span class="line">console.log(require)</span><br><span class="line"></span><br><span class="line">// 模块对象</span><br><span class="line">console.log(module)</span><br><span class="line"></span><br><span class="line">// 导出对象别名</span><br><span class="line">console.log(exports)</span><br><span class="line"></span><br><span class="line">// 当前文件的绝对路径</span><br><span class="line">console.log(__filename)</span><br><span class="line"></span><br><span class="line">// 当前文件所在目录</span><br><span class="line">console.log(__dirname)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、ESM 中无法引用CommonJS中的那些模块全局成员</span><br><span class="line">2、require, module, exports 可通过import 和export 代替</span><br><span class="line">3、__filename 和 __dirname 通过import 对象的 meta 属性获取</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const currentUrl = import.meta.url</span><br><span class="line">console.log(currentUrl)</span><br><span class="line">// 通过 url 模块的 fileURLToPath 方法转换为路径</span><br><span class="line">import &#123; fileURLToPath &#125; from &#x27;url&#x27;</span><br><span class="line">import &#123; dirname &#125; from &#x27;path&#x27;</span><br><span class="line">const __filename = fileURLToPath(import.meta.url)</span><br><span class="line">const __dirname = dirname(__filename)</span><br><span class="line">console.log(__filename)</span><br><span class="line">console.log(__dirname)</span><br></pre></td></tr></table></figure>
<h3 id="ES-Modules-in-Node-js-新版本进一步支持"><a href="#ES-Modules-in-Node-js-新版本进一步支持" class="headerlink" title="ES Modules in Node.js - 新版本进一步支持"></a>ES Modules in Node.js - 新版本进一步支持</h3><p>Node v12 之后的版本，可以通过package.json 中添加type字段为module，将默认模块系统修改为 ES Module<br>此时就不需要修改文件扩展名为 .mjs 了<br>如果需要在type=module的情况下继续使用CommonJS，需要将文件扩展名修改为 .cjs<br>package.json:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;type&quot;: &quot;module&quot; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ES-Modules-in-Node-js-Babel-兼容方案"><a href="#ES-Modules-in-Node-js-Babel-兼容方案" class="headerlink" title="ES Modules in Node.js - Babel 兼容方案"></a>ES Modules in Node.js - Babel 兼容方案</h3><p>安装babel:yarn add @babel/node @babel/core @babel/preset-env –dev<br>运行babel-node测试:yarn babel-node index.js --presets=@babel/preset-env<br>**.babelrc 配置 **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;plugins&quot;: [ &quot;@babel/plugin-transform-modules-commonjs&quot; ] &#125;</span><br></pre></td></tr></table></figure>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>问： 你讲讲前端模块化吧<br>答： 模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。<br>问：模块化有哪几种标准？<br>答： 目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统<br>问：ES Modules 和 CommonJS的一些区别<br>答：<br>使用语法层面，CommonJs是通过module.exports，exports导出，require导入；ESModule则是export导出，import导入<br>CommonJs是运行时加载模块，ESModule是在静态编译期间就确定模块的依赖<br>ESModule在编译期间会将所有import提升到顶部，CommonJs不会提升require<br>CommonJs导出的是一个值拷贝，会对加载结果进行缓存，一旦内部再修改这个值，则不会同步到外部。ESModule是导出的一个引用，内部修改可以同步到外部<br>CommonJs中顶层的this指向这个模块本身，而ESModule中顶层this指向undefined<br>CommonJS加载的是整个模块，将所有的接口全部加载进来，ESModule可以单独加载其中的某个接口</p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象 B 复制另一个对象 A，当改变 B 对象的值时 A 对象的值也随之改变。<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123; a: 1, b: 5, c: 3 &#125;</span><br><span class="line">var obj2 = obj1</span><br><span class="line">obj2.b = 2</span><br><span class="line">console.log(obj1.b) //2</span><br><span class="line">console.log(obj2.b) //2</span><br></pre></td></tr></table></figure>

<p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，任何一个修改都会使得所有对象的值被修改，因为它们共用一条数据。</p>
<h1 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象 B 复制另一个对象 A，当改变 B 对象的值时 A 对象的值不会改变。<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">var b = a</span><br><span class="line">b = 3</span><br><span class="line">console.log(a) //2</span><br><span class="line">console.log(b) //3</span><br></pre></td></tr></table></figure>

<p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p>
<h1 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h1><h2 id="JSON-Stringify-JSON-parse-不支持多层引用嵌套，不支持函数-Map、Sep-等类型的数据"><a href="#JSON-Stringify-JSON-parse-不支持多层引用嵌套，不支持函数-Map、Sep-等类型的数据" class="headerlink" title="JSON.Stringify(JSON.parse()) 不支持多层引用嵌套，不支持函数 Map、Sep 等类型的数据"></a>JSON.Stringify(JSON.parse()) 不支持多层引用嵌套，不支持函数 Map、Sep 等类型的数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;a:1,b:5,c:3&#125;</span><br><span class="line">var obj2 = JSON.Stringify(JSON.parse(obj1))</span><br><span class="line">obj2.b = 2</span><br><span class="line">console.log(obj1.b)  //5</span><br><span class="line">console.log(obj2.b)  //2</span><br></pre></td></tr></table></figure>

<h2 id="展开运算符-…"><a href="#展开运算符-…" class="headerlink" title="展开运算符 …"></a>展开运算符 …</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;a:1,b:5,c:3&#125;</span><br><span class="line">var obj2 = (...obj1)</span><br><span class="line">obj2.b=2</span><br><span class="line">console.log(obj1.b)  //5</span><br><span class="line">console.log(obj2.b)  //2</span><br></pre></td></tr></table></figure>

<h2 id="Object-asssign（target-sourse）"><a href="#Object-asssign（target-sourse）" class="headerlink" title="Object.asssign（target,sourse）"></a>Object.asssign（target,sourse）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;a:1,b:5,c:3&#125;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;,obj1)</span><br><span class="line">obj2.b = 2</span><br><span class="line">console.log(obj1.b)  //5</span><br><span class="line">console.log(obj2.b)  //2</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝函数，递归"><a href="#深拷贝函数，递归" class="headerlink" title="深拷贝函数，递归"></a>深拷贝函数，递归</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// target 要拷贝的对象</span><br><span class="line">function deepClone(target)&#123;</span><br><span class="line">  //定义一个拷贝对象</span><br><span class="line">  let result</span><br><span class="line">  // 判断拷贝目标是不是Object对象</span><br><span class="line">  if(typeof target === &#x27;object&#x27;)&#123;</span><br><span class="line">      // 判断是否是数组类型</span><br><span class="line">        if(Array.isArray(target))&#123;</span><br><span class="line">          // 定义为数组</span><br><span class="line">          result = []</span><br><span class="line">             for(let i in target)&#123;</span><br><span class="line">             result.push(deepClone(target[i]))</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; else if(target === null)&#123;</span><br><span class="line">          // 直接赋值</span><br><span class="line">          result = null</span><br><span class="line">        &#125;else if(target.constructor === RegExp)&#123;</span><br><span class="line">          // 直接赋值</span><br><span class="line">          result = target</span><br><span class="line">          // 不是特殊的对象</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">          for(let i in target)&#123;</span><br><span class="line">          // 递归</span><br><span class="line">          result[i] = deepClone(target[i])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 基本数据类型  直接赋值</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      result = target</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">a:&#123;z:1,c:null&#125;,</span><br><span class="line">b:[1,2,3,5],</span><br><span class="line">c:function()&#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = deepClone(obj1)</span><br><span class="line">console.log(obj2)</span><br><span class="line">obj2.b[0] = 2</span><br><span class="line">obj2.a[0] = 2</span><br><span class="line">console.log(obj1.a)</span><br><span class="line">console.log(obj2.a)</span><br><span class="line">console.log(obj1.b)</span><br><span class="line">console.log(obj2.b)</span><br><span class="line">console.log(obj2.c())</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2022/09/30/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="跨域是什么？"><a href="#跨域是什么？" class="headerlink" title="跨域是什么？"></a>跨域是什么？</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。</p>
<h2 id="跨域报错信息"><a href="#跨域报错信息" class="headerlink" title="跨域报错信息"></a>跨域报错信息</h2><p><img src="/2022/09/30/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="跨域限制的原因"><a href="#跨域限制的原因" class="headerlink" title="跨域限制的原因"></a>跨域限制的原因</h2><p>浏览器为了保证网页的安全，出的同源协议策略。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致」才是同源。</p>
<h1 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h1><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="方式一：cors"><a href="#方式一：cors" class="headerlink" title="方式一：cors"></a>方式一：cors</h3><p>目前最常用的一种解决办法，通过设置后端允许跨域实现。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。CORS 需要浏览器和服务器同时支持。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>我们的服务器端需要设置一个源，这个源可以写*(具体地址)，此处的*表示可以携带多个源，表示支持多源，就不能再允许携带 cookie 了（因为设置了多源，浏览器为了保证 cookie 的安全，所以设置为不允许携带）<br>res.setHeader(‘Access-Control-Allow-Origin’, ‘*‘);<br>res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”)</p>
<h3 id="方式二：nginx-反向代理"><a href="#方式二：nginx-反向代理" class="headerlink" title="方式二：nginx 反向代理"></a>方式二：nginx 反向代理</h3><p>跨域限制的时候浏览器不能跨域访问服务器， nginx 反向代理，让请求发给代理服务器，静态页面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>
<h3 id="方式三：JSONP"><a href="#方式三：JSONP" class="headerlink" title="方式三：JSONP"></a>方式三：JSONP</h3><p>利用的原理是 script 标签可以跨域请求资源，将回调函数作为参数拼接在 url 中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成 javascript。</p>
<h4 id="jsonp-的作用"><a href="#jsonp-的作用" class="headerlink" title="jsonp 的作用"></a>jsonp 的作用</h4><p>利用浏览器的同源策略，解决跨域问题</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>简单适用，兼容性好（可以兼容低版本 IE）</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只支持 get 请求，不支持 post 请求，导致数据不安全。</p>
<h3 id="方式四：使用-jQuery-的-jsonp-插件"><a href="#方式四：使用-jQuery-的-jsonp-插件" class="headerlink" title="方式四：使用 jQuery 的 jsonp 插件"></a>方式四：使用 jQuery 的 jsonp 插件</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p>
<h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p><img src="/2022/09/30/%E8%B7%A8%E5%9F%9F/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化(二)</title>
    <url>/2023/05/06/%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。</p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义模块math.js</span><br><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; //在这里写上需要向外暴露的函数、变量</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="line">var math = require(&#x27;./math&#x27;);</span><br><span class="line">math.add(2, 5);</span><br><span class="line"></span><br><span class="line">// 引用核心模块时，不需要带路径</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure>
<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<h1 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h1><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。<br>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 网页中引入require.js及main.js **/</span><br><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">/** main.js 入口文件/主模块 **/</span><br><span class="line">// 首先用config()指定各模块路径和引用名</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: &quot;js/lib&quot;,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js</span><br><span class="line">    &quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 执行基本操作</span><br><span class="line">require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;</span><br><span class="line">  // some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义math.js模块</span><br><span class="line">define(function () &#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = function (x, y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义一个依赖underscore.js的模块</span><br><span class="line">define([&#x27;underscore&#x27;],function(_)&#123;</span><br><span class="line">  var classify = function(list)&#123;</span><br><span class="line">    _.countBy(list,function(num)&#123;</span><br><span class="line">      return num &gt; 30 ? &#x27;old&#x27; : &#x27;young&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([&#x27;jquery&#x27;, &#x27;math&#x27;],function($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(&quot;#sum&quot;).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h1><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; </span><br><span class="line">    // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    if (false) &#123;</span><br><span class="line">      // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&#x27;./a&#x27;); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        var b = require(&#x27;./b&#x27;);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var $ = require(&#x27;jquery.js&#x27;);</span><br><span class="line">    var add = function(a,b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([&#x27;math.js&#x27;], function(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h1><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &#x27;./math&#x27;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** export default **/</span><br><span class="line">//定义输出</span><br><span class="line">export default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from &#x27;./math&#x27;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<h1 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h1><ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
</ol>
<ul>
<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>
<ol start="2">
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<ul>
<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ul>
<p>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
</search>
